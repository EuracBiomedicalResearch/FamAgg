```{r echo=FALSE, results='asis'}
BiocStyle::markdown()
```

<!--
%%\VignetteIndexEntry{Pedigree analysis and familial aggregation}
%%\VignetteKeywords{Genetics}
%%\VignetteDepends{FamAgg}
%%\VignettePackage{FamAgg}
%%\VignetteEngine{knitr::rmarkdown}
-->

---
title: "Pedigree analysis and familial aggregation"
author: "Johannes Rainer, Daniel Taliun, Christian X. Weichenberger"
date: "2015-10-09"
graphics: yes
output:
  BiocStyle::html_document:
    toc_depth: 2
  BiocStyle::pdf_document:
    toc_depth: 2
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

# Introduction

This package provides basic pedigree analysis and plotting utilities as well as
a variety of methods to evaluate familial clustering of cases from a given
trait. Identification of families or groups of individuals within families with
significant aggregation of cases can aid also in the selection of interesting
and promising individuals for whole genome or exome sequencing projects.

# Basic pedigree operations

In the examples below we perform some simple pedigree operations, such as
plotting the pedigree for an individual or family, finding the closest common
ancestor for a set of individuals in a pedigree or retrieving the identifiers
(IDs) of all ancestors for an individual.
Basic pedigree information is stored in `FAData` objects, thus we first generate
such an object from a subset of the Minnesota Breast Cancer Study provided by
the `kinship2` package.

```{r warning=FALSE, message=FALSE}
library(FamAgg)

data(minnbreast)
## Subsetting to only few families of the whole data set.
mbsub <- minnbreast[minnbreast$famid %in% 4:14, ]
mbped <- mbsub[, c("famid", "id", "fatherid", "motherid", "sex")]
## Renaming column names.
colnames(mbped) <- c("family", "id", "father", "mother", "sex")
## Defining the optional argument age.
endage <- mbsub$endage
names(endage) <- mbsub$id
## Create the object.
fad <- FAData(pedigree=mbped, age=endage)
```

We can access all the pedigree information stored in this object using the
`pedigree` method, but also using `$`. The row names of the pedigree
`data.frame` as well as the names of the vectors returned by `$` are the IDs of
the individuals in the pedigree.

```{r }
## Use the pedigree method to access the full pedigree
## data.frame,
head(pedigree(fad))

## or access individual columns using $.
## The ID of the father (0 representing "founders"):
head(fad$father)
## Mother:
head(fad$mother)
## Sex:
head(fad$sex)

## We can also access the age of each individual, if
## provided.
head(age(fad))
```

To extract the pedigree for a single family we can use the `family` method,
specifying either the ID of the family or the ID of an individual in the family.

```{r }
## Extract the pedigree information from family "4"...
nrow(family(fad, family=4))

head(family(fad, family=4))

## ...which is the same as extracting the family pedigree
## for an individual of this family.
head(family(fad, id=3))

## Note that IDs are internally always converted to character,
## thus, using id=3 and id="3" return the same information.
head(family(fad, id="3"))
```

Alternatively, we could subset the `FAData` to individuals of a single family.

```{r }
## Subset the object to a single family.
fam4 <- fad[fad$family == "4", ]
table(fam4$family)
```

To explore this family we can plot its pedigree. By default, the plotting
capabilities of the `kinship2` package are used to plot pedigrees, but
alternatively, if all required dependencies are available, the `HaploPainter`
[@Thiele:2005] perl script (<http://haplopainter.sourceforge.net/>) can be
used instead. The `switchPlotfun` function can be used to switch the plotting
back-end. Available arguments are `ks2paint` and `haplopaint` for `kinship2`
and `HaploPainter` plotting, respectively. Note however, that `HaploPainter`
only allows to export plots to a file, while `kinship2` plotting allows, in
addition to export the plot, also to show it as a *standard* `R` plot.

Below we use the `switchPlotfun` to ensure the use of `kinship2` plotting
(usually not required) and plot the full available pedigree of individual `3`.
If the age of individuals is available, it will be plotted below the
individual's ID.

```{r family-4-pedigree, message=FALSE, fig.align='center'}
switchPlotfun("ks2paint")
## By supplying device="plot", we specify that we wish to visualize the
## pedigree in an R plot. This is the default for "ks2paint", anyway.
plotPed(fad, id=3, device="plot")
```

The pedigree for an individual or a list of individuals can be extracted using
the `buildPed` method. By default the method first tries to identify all parents
up to 3 generations in the pedigree, and subsequently all children of the
individuals and all identified parents.

```{r }
## Build the pedigree for individual 3.
fullPed <- buildPed(fad, id="3")
nrow(fullPed)
```

Alternatively, we can extract the smallest possible pedigree for a list of
individuals by specifying `prune=TRUE`. Internally, the function transforms the
pedigree into a graph, tries to find all paths between the individuals and
returns the sub-graph of all individuals along with individuals along the paths
between them.

```{r }
## Find the subpedigree for individuals 21, 22 and 17.
buildPed(fad, id=c(21, 22, 17), prune=TRUE)
```

And the pedigree plot for that subset of the whole family:

```{r family-sub-pedigree, message=FALSE, fig.align='center'}
plotPed(fad, id=c(21, 22, 17), prune=TRUE)
```

Note that the pedigree returned by the `buildPed` method for an individual might
be different than the pedigree of a whole family. The pedigree returned by
`buildPed` contains only individuals that share kinship with the specified
individual. To exemplify this, we plot the pedigree for the family `14` in the
Minnesota Breast Cancer data set. Note that the individuals in the pedigree plot
depicted as diamonds are individuals with unknown gender. (The message
"Did not plot&#x2026;" is issued by the `kinship2` plotting function and indicates
singletons that are assigned to the family but do neither have parents nor
children.)

```{r pedigree-family-14, message=FALSE, fig.align='center'}
plotPed(fad, family="14", cex=0.4)
```

In this family, founder `441` is the founder of two family branches. Building
the pedigree for individual `440` will not include any of the individuals of the
second branch, as he does not share kinship with any of them. The pedigree built
for `447` on the other hand contains also individuals from the second branch as
she shares kinship with them (*via* her mother `441`).

```{r }
## Check if we have individual 26064 from the second branch in the pedigree
## of individual 440.
any(buildPed(fad, id="440")$id == "26064")

## What for the pedigree of 447?
any(buildPed(fad, id="447")$id == "26064")
```

A family pedigree may consist of many founder couples (i.e. individuals for
which neither father nor mother is defined in the pedigree). To identify the
pedigree's founder couple (being the couple with the largest number of offspring
generations in the pedigree) the `findFounders` method can be used. Note that
the function returns always only one couple, even if there might be two founder
couples in the family pedigree with the same number of offspring generations.

```{r }
## Find founders for family 4.
findFounders(fad, "4")
```

Alternatively, it might be of interest to determine the closest common ancestor
between individuals in a pedigree. Below we use the `getCommonAncestor` method
to identify the common ancestor for individuals `21`, `22` and `17` (which we
know from the pedigree a bit above are `1` and `2`).

```{r }
## Find the closest common ancestor.
getCommonAncestor(fad, id=c(21, 22, 17))
```

Other useful methods are `getChildren`, `getAncestors` and `getSiblings`, that
return the children (or all offspring generations up to a specified level), the
parents (or all ancestors) or the siblings for the specified individuals,
respectively.

```{r }
## Get the children of ID 4.
getChildren(fad, id="4", max.generations=1)

## Get the offspring.
getChildren(fad, id="4")

## Get all ancestors.
getAncestors(fad, id="4")

## Get the siblings.
getSiblings(fad, id=c("4"))
```

In the whole Minnesota Breast Cancer data set there are 426 families
corresponding to 426 founders that had cancer during the screening phase between
1944 and 1952.
In the code block below we identify the affected founders per family.

```{r }
## Add the trait information to the FAData object.
cancer <- mbsub$cancer
names(cancer) <- as.character(mbsub$id)
trait(fad) <- cancer

## Identify the affected founders:
## First all affected individuals:
affIds <- affectedIndividuals(fad)
## Identify founders for each family:
founders <- lapply(unique(fad$family), function(z){
    return(findFounders(fad, family=z))
})
names(founders) <- unique(fad$family)

## Track the affected founder:
affFounders <- lapply(founders, function(z){
    return(z[z %in% affIds])
})
## Interestingly, not all founders are affected! It seems in some cases
## parents of the affected participants in the screening phase have also
## been included.
affFounders <- affFounders[unlist(lapply(affFounders, length)) > 0]

## The number of families analyzed:
length(founders)

## The number of families with affected founder:
length(affFounders)
```

Unexpectedly, only in few families one of the founders is affected. For the
other families additional (unaffected) ancestors might have been added at a
later time point.

Next we get the number of affected individuals that are related to these
affected founders.

```{r }
kin2affFounders <- shareKinship(fad, unlist(affFounders))

## How many of these are affected?
sum(kin2affFounders %in% affIds)

## How many affected are not related to an affected founder?
sum(!(affIds %in% kin2affFounders))
```

## Pedigree analysis methods

In this section we perform some more advanced pedigree operations.
First we identify all individuals in the pedigree that share kinship with
individual `4`.

```{r }
## Get all individuals sharing kinship with individual 4.
shareKinship(fad, id="4")
```

Next we determine generations within the pedigree. Generations can only be
estimated for a single family, since in most instances e.g. the year of birth is
not available. Thus, generations are estimated considering the relation between
individuals, starting from the founder couple, i.e. generation 0, assigning
generation 1 to their children and all the mates of their children and so
on. The `estimateGenerations` method calculates such generation numbers for each
family defined in the object (or for a single family, if the family ID is
provided). The result is returned as a list with the list names corresponding to
the family ID and the list elements being the estimated generation numbers
(with names corresponding to the ID of the respective individual).

```{r }
## Estimate generation levels for all families.
estimateGenerations(fad)[1:3]
```

Individuals without generation level (i.e. with an `NA`) are not connected to
any other individual in the pedigree (and thus most likely represent errors in
the pedigree).

In addition, it is also possible to calculate generation levels relative to a
(single) specified individual:

```{r }
gens <- generationsFrom(fad, id="4")
```

We can draw these generation numbers into the pedigree:

```{r family-four-gens-rel-to-four, message=FALSE, fig.align='center'}
plotPed(fad, family=4, label2=gens)
```

## Additional plotting options

If a trait information is available it might be of interest to highlight
affected individuals in the pedigree. Trait information should always be coded
as `0` (or `FALSE`) for unaffected and `1` (or `TRUE`) for affected. In the
example below we use the *cancer* information from the Minnesota Breast Cancer
Study.

```{r results='hide', message=FALSE}
## Extract the cancer trait information.
tcancer <- mbsub$cancer
names(tcancer) <- mbsub$id
## Set the trait.
trait(fad) <- tcancer
```

We can now extract the trait information from the object or identify directly
the phenotyped or affected individuals.

```{r }
## Extract the trait information.
head(trait(fad))

## We can also extract the IDs of the affected individuals.
head(affectedIndividuals(fad))

## Or the IDs of the phenotyped individuals.
head(phenotypedIndividuals(fad))
```

Plotting a `FAData` object with trait information results in a pedigree plot
with highlighted affected individuals (for `kinship2` pedigree plotting:
affected, unaffected and not phenotyped are represented as filled symbols, open
symbols and symbols with a question mark inside, respectively).

```{r family-pedigree-affected, message=FALSE, fig.align='center'}
## Plotting the pedigree for family "9".
plotPed(fad, family="9")
```

In addition we can manually highlight individuals using the `highlight.ids`
argument. For `kinship2` pedigree plotting, a list of length 2 is supported as
argument `highlight.ids`, with the first element being plotted on the top left
corner of the symbol and the second element on the top right corner.

```{r family-pedigree-affected-highlighted, message=FALSE, fig.align='center'}
## Plotting the pedigree for family "9".
plotPed(fad, family="9", highlight.ids=list(a=c("185", "201", "198"),
					    b=c("193")))
```

An alternative way to highlight individuals or add text to the plot is to use
the arguments `label1`, `label2` and `label3` or the `plotPed` method.

## Graph utilities

Pedigrees can also be transformed to graphs using the `ped2graph` function. That
way all graph theory methods implemented in e.g. the `igraph` package can be
applied to pedigrees.

```{r }
## Transform the full pedigree to a graph.
fullGraph <- ped2graph(pedigree(fad))

## In addition build the graph for a single family.
singleFam <- ped2graph(family(fad, family=4))
```

We can plot these pedigrees also as graph and could use any of the layout
methods provided in the `igraph` package.

```{r graph-plots, fig.align='center'}
## Build the layout.
plot(fullGraph)
lay <- layout_(singleFam, on_grid())
plot(singleFam, layout=lay)
```

The `connectedSubgraph` function implemented in the `FamAgg` package provides
additional functionality to find the smallest connected subgraph of a list of
submitted nodes (i.e. individuals).

In the code below we want to extract the smallest possible connected subgraph of
the pedigree-graph of family 4 containing individuals `7`, `8`, `27` and `17`.

```{r }
subgr <- connectedSubgraph(singleFam, nodes=c("7", "8", "27", "17"))
```

This is in principle what the `buildPed` method with the option `prune=TRUE`
does to find the smallest pedigree for a set of individuals, only that
`buildPed` ensures that also eventually missing parents are added.

```{r subgraph-plot, fig.align='center'}
## Plot the graph.
plot(subgr)
## Similar to buildPed/plotPed with prune=TRUE.
plotPed(fad, id=c("7", "8", "17", "27"), prune=TRUE)
```

# Testing for familial aggregation

Familial aggregation aims to identify families within large ancestral
pedigrees that show a non-random aggregation of traits.  One such method to
test if a disease is clustered in families is the *genealogical index*
[@Hill:1980tz]. For a given trait (e.g. whether or not an individual was
diagnosed with a certain type of cancer), the method computes the mean kinship
between affected individuals (cases) in the whole pedigree along with mean
kinship values of randomly drawn sets of individuals. The distribution of
average kinship values among the control sets is then used to estimate the
probability that the observed level of kinship among the cases is due to
chance.

We next calculate the genealogical index for cancer occurrence in a subset of
the Minnesota Breast Cancer Record data set. We first generate the appropriate
`FAData` object containing the pedigree and perform the analysis using the
`genealogicalIndexTest` method on the `cancer` trait in which cases of breast or
prostate cancer are reported.  In its default setting the `genealogicalIndexTest`
function uses all phenotyped individuals in the pedigree as control population
from which sets of random samples equal in size to the number of affected are
drawn.

Note that, to reduce computation time, we perform the analysis only on a subset
of families from the Minnesota Breast Cancer record and reduce the number of
simulation runs. We specifically selected some families with a high percentage
of cancer cases, thus, the analysis presented here is biased.

```{r warning=TRUE, message=FALSE}
data(minnbreast)
## Subset the dataset to reduce processing time.
mbsub <- minnbreast[minnbreast$famid %in% c(4:60, 432), ]
## Use the whole dataset instead:
## mbsub <- minnbreast

## Define the number of simulations we perform.
## nsim <- 50000
nsim <- 400

mbped <- mbsub[, c("famid", "id", "fatherid", "motherid", "sex")]
## Renaming column names.
colnames(mbped) <- c("family", "id", "father", "mother", "sex")
## Create the FAData object.
fad <- FAData(pedigree=mbped)

## Define the trait.
tcancer <- mbsub$cancer
names(tcancer) <- as.character(mbsub$id)
## Calculate the genealogical index:
gi <- genealogicalIndexTest(fad, trait=tcancer, traitName="cancer", nsim=nsim)

## Display the result:
result(gi)
```

Thus, according to the genealogical index test, a clustering of cancer cases is
present in the analyzed pedigree. The warning messages just indicate that some
individuals have been excluded from the test since they were either not phenotyped
in the trait (i.e. have a missing value in trait), or are not *connected* in the
family pedigree (do not share kinship with any other individual in the pedigree
after removing non-phenotyped individuals).

The genealogical index implementation in this package adds some more flexibility
to the original approach. The definition of the appropriate set of control
individuals from which random samples are drawn can be specified with the
`controlSetMethod` argument. Also, it is possible to perform a stratified
sampling, e.g. if the group of affected cases in a pedigree consists of 5
female and 3 male individuals, submitting the sex of each individual in the
pedigree with the argument `strata` (i.e. `strata=fad$sex`, with `fad` being the
`FAData` object on which the analysis is performed) allows the function to
define random control sets with the same proportion of male/female individuals.

In the next example we use the `getSexMatched` function to define the set of
control individuals and also the `getExternalMatched` submitting the gender
information of each individual. The results from both approaches are essentially
identical, and in the present data set not that useful, as the Minnesota Breast
Cancer data set lists both, breast cancer and prostate cancer in column
`cancer`, thus, the set of control individuals will contain all individuals with
known sex.

```{r warning=FALSE, eval=FALSE}
## Calculate the genealogical index using random sampling from a sex matched control set.
giSexMatch <- genealogicalIndexTest(fad, trait=tcancer, traitName="cancer", nsim=nsim,
				controlSetMethod="getSexMatched")

## Use an external vector to perform the matching. The results are essentially identical.
giExtMatch <- genealogicalIndexTest(fad, trait=tcancer, traitName="cancer", nsim=nsim,
				controlSetMethod="getExternalMatched", match.using=fad$sex)
```

Note that any matching or stratified sampling can lead to the exclusion of
individuals with missing values in either the matching criteria or the strata.

In the Minnesota Breast Cancer data set, the number of prostate cancer cases is
much lower than the number of breast cancer cases, thus, simple random sampling
might result in an biased genealogical index estimate since about the same
proportion of male and female individuals will be sampled. To account for such
cases a stratified sampling, as performed below, can be used instead.

```{r warning=FALSE}
## Evaluate the proportion of male and femal cases.
table(gi$sex[affectedIndividuals(gi)])

## We can use the gender information to perform stratified sampling, i.e.
## in each permutation a random set of 3 male and 15 females will be selected.
giStrata <- genealogicalIndexTest(fad, trait=tcancer, traitName="cancer", nsim=nsim,
			      strata=fad$sex)

result(giStrata)
```

At last we plot the result from the simulation. The blue vertical line in the
plot below represents the mean kinship value between all affected in the
pedigree. The distribution of mean kinship values from the 1000 randomly drawn
sets are shown in grey color.

```{r mbreast-genealogical-index-result, message=FALSE, warning=FALSE, fig.align='center'}
## Plot the result.
plotRes(giStrata)
```

In the example above we tested for an enrichment of cancer cases in the full
data set, i.e. across all families. In addition we could however also perform
the test individually for each family, by setting the `perFamilyTest` parameter
of the `genealogicalIndexTest` to `TRUE`, and thus test for a clustering of cancer
cases within each family.

A per-individual risk of e.g. disease can be calculated using the *familial
incidence rate* (FR) [@Kerber:1995cx]. This measure considers the kinship of each
individual with any affected in a given trait in the pedigree and the time at
risk for each individual. Thus, the FR is an estimate for the risk per gene-time
for each individual given the disease-experience in the cohort.

As *time at risk* for each individual we use the *endage* column in the
Minnesota Breast Cancer data set, that represents the participant's age at the
last follow-up or at cancer incidence. This estimate of time at risk is rather
crude and in a real life situation a better, more accurate, estimate that bases
e.g. on the birth dates and dates of last follow up or incidence might be used
instead. See the help of functions `estimateTimeAtRisk` and `sliceAge` for
details and options related to *time at risk*.

```{r warning=FALSE}
## Estimate the risk for each individual using the familial incidence rate method.
## We use the endage provided in the minnesota breast cancer record as
## a measure for time at risk.
fr <- familialIncidenceRate(fad, trait=tcancer, timeAtRisk=mbsub$endage)

## Extracting the actual FR values; the analysis was performed on the
## complete pedigree and the results are thus present in the first
## element of the list.
fr <- fr[[1]]
```

Next we calculate the mean FR within each family and plot this information.

```{r mbreast-mean-fr-per-family, message=FALSE, warning=FALSE, fig.align='center'}
## Split the FR by family and average the values within each.
frFam <- split(fr, f=fad$family)
frFamAvg <- lapply(frFam, mean, na.rm=TRUE)

## Sort and plot the averages.
frFamAvg <- sort(unlist(frFamAvg), decreasing=TRUE)
plot(frFamAvg, type="h", xaxt="n", xlab="", ylab="mean FR",
     main="Per family averaged familial incidence rate")
axis(side=1, las=2, at=1:length(frFamAvg), label=names(frFamAvg))
```

Not unexpectedly, individuals in some families have on average a higher familial
incidence rate, and thus a higher risk of cancer than others.

Next we use the *kinship sum test* that evaluates familial aggregation based
on the sum of kinship values between affected cases. The test identifies
affected individuals exhibiting a higher relationship to other affected
individuals than would be expected by chance. By specifying the `strata` we
perform sex-stratified random sampling, i.e. ensure that the proportion of male
and female individuals in each randomly sampled group matches the corresponding
proportions in the *real*, observed, affected.

```{r }
## Perform the kinship sum test.
kinSum <- kinshipSumTest(fad, trait=tcancer, traitName="cancer",
			   nsim=nsim, strata=fad$sex)
head(result(kinSum))
```

The warning messages above indicate that for some individuals in the pedigree no
gender information is provided. These individuals have to be excluded from the
stratified random sampling.

Next we identify those individuals that have a significant kinship sum accepting
a 10% false discovery rate (FDR).

```{r }
## Extract the IDs of the individuals with significant kinship. By default, the raw p-values
## are adjusted for multiple hypothesis testing using the method from Benjamini and Hochberg
kinSumRes <- result(kinSum)
kinSumIds <- as.character(kinSumRes[kinSumRes$padj < 0.1, "affected_id"])

## From which families are these?
table(kinSumRes[kinSumIds, "family"])
```

Thus, most of the identified significant individuals are from one family.
Next we compare the above calculated FR scores of affected or unaffected (but
phenotyped) individuals in this family to the FR scores of affected or
unaffected individuals of all other families.

```{r mbreast-family-432-FR-compared-to-others, message=FALSE, warning=FALSE, fig.align='center'}
## Get the familial ratio of the significant in this family, of all in this family,
## and of all others.
famId <- kinSumRes[1, "family"]

## Extract the family:
fam <- family(kinSum, family=famId)

## Stratify individuals in affected/unaffected
strat <- rep("All, unaff.", length(kinSum$id))
strat[which(kinSum$affected > 0)] <- "All, aff."
strat[kinSum$id %in% fam$id] <- paste0("Fam ", famId, ", unaff.")
strat[kinSum$id %in% fam$id[which(fam$affected > 0)]] <- paste0("Fam ",
								famId,
								", aff.")

famData <- data.frame(fr=fr, group=strat)
boxplot(fr~group, data=famData, na.rm=TRUE, ylab="FR",
	col=rep(c("#FBB4AE", "#B3CDE3"), 2))
```

As expected, the familial incidence rate (i.e., in the present data set, the
risk of individuals to get cancer, given their kinship to other cancer cases)
for individuals (whether affected or yet unaffected) in this family is higher
than in the data set analyzed here.

Next we plot the pedigree of this family.

```{r mbreast-family-432-affected, message=FALSE, warning=FALSE, fig.align='center'}
## Plot the pedigree for the family of the selected individual removing
## all individuals that were not phenotypes.
plotPed(kinSum, id=kinSumIds[1], cex=0.3, only.phenotyped=TRUE)
```

And, at last also the kinship sum for the individuals with the largest kinship
sum in relation to the *expected* kinship sums from the Monte Carlo simulations.

```{r mbreast-family-432-affecte-res, message=FALSE, warning=FALSE, fig.align='center'}
plotRes(kinSum, id=kinSumIds[1])
```

Another test to identify familial aggregation is the *kinship group test*. This
test first defines for each affected a group of individuals considering only
individuals that are as closely related as the most distant affected individual.
For each of these kinship groups two tests are then performed, one by comparing
the mean kinship among affected in the group with the mean kinship from Monte
Carlo simulations (ratio test) and one evaluating the largest observed kinship
value between affected individuals with those of random samples from the
simulation (kinship group test).

Below we perform the kinship group test for the Minnesota Breast Cancer data
set. Again we specify the `strata` argument and thus perform sex-stratified
random sampling.

```{r }
## Calculate the kinship test.
kinGroup <- kinshipGroupTest(fad, trait=tcancer, traitName="cancer",
			     nsim=nsim, strata=fad$sex)
head(result(kinGroup))
```

Also the kinship group test finds a significant aggregation of cases in
family 432. In fact, as we see further below, the test identified a subgroup in
this family with an exceptional high proportion of cases.

Below we summarize the results further by listing the total number of families
in the pedigree and the number of families in which kinship groups with
significant kinship p-value and significant ratio p-value (both at a 5% FDR).

```{r }
kinGroupRes <- result(kinGroup)
## Creating a data.frame with the summarized results.
resTab <- data.frame(total_families=length(unique(kinGroup$family)),
		     ratio_sign=length(unique(
			 kinGroupRes[kinGroupRes$ratio_padj < 0.05, "family"]
		     )),
		     kinship_sign=length(unique(
			 kinGroupRes[kinGroupRes$kinship_padj < 0.05, "family"]
		     ))
		     )
resTab
```

The most significant kinship group which was identified by the kinship group
test is shown in the figure below. The mother (individual `17609`) in this group
and all her daughters have cancer, the mother is however not directly related to
the affected founder of this family (individual `17517` of family `432`, see
figure above for the full pedigree of this family).
We are also submitting the familial incidence ratio values calculated above with
argument `label1` which are then displayed below the ID of each individual in
the plot.

```{r mbreast-family-432-affecte-res-kinship, message=FALSE, warning=FALSE, fig.align='center'}
plotPed(kinGroup, id=kinGroupRes[kinGroupRes$family == "432", "group_id"][1],
	prune=TRUE, label1=fr)
```

# References