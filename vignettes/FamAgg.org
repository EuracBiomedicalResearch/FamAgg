#+TITLE: Pedigree analysis and familial aggregation
#+AUTHOR:    Johannes Rainer, Daniel Taliun, Christian X. Weichenberger
#+EMAIL:     johannes.rainer@eurac.edu
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: ^:{} toc:nil
#+PROPERTY: exports code
#+PROPERTY: session *R*

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+latex: %\VignetteEngine{knitr::knitr}
#+latex: %\VignetteIndexEntry{Pedigree analysis and familial aggregation}
#+latex: %\VignetteKeywords{Genetics}
#+latex: %\VignetteDepends{FamAgg}
#+latex: %\VignettePackage{FamAgg}

#+BEGIN_SRC R :ravel echo=FALSE, results='asis'
  BiocStyle::markdown()
#+END_SRC

#+BEGIN_HTML
<!--
%%\VignetteIndexEntry{Pedigree analysis and familial aggregation}
%%\VignetteKeywords{Genetics}
%%\VignetteDepends{FamAgg}
%%\VignettePackage{FamAgg}
%%\VignetteEngine{knitr::rmarkdown}
-->

---
title: "Pedigree analysis and familial aggregation"
author: "Johannes Rainer, Daniel Taliun, Christian X. Weichenberger"
date: "2015-10-09"
graphics: yes
output:
  BiocStyle::html_document:
    toc_depth: 2
  BiocStyle::pdf_document:
    toc_depth: 2
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

#+END_HTML


* How to export this to a =Rmd= vignette			   :noexport:

Use =ox-ravel= to export this file as an R markdown file (=C-c C-e m
r=). That way we don't need to edit the resulting =Rmd= file.

* How to export this to a =Rnw= vignette 			   :noexport:

*Note*: this is deprecated! Use the =Rmd= export instead!

Use =ox-ravel= from the =orgmode-accessories= package to export this file to a =Rnw= file. After export edit the generated =Rnw= in the following way:

1) Delete all =\usepackage= commands.
2) Move the =<<style>>= code chunk before the =\begin{document}= and before =\author=.
3) Move all =%\Vignette...= lines at the start of the file (even before =\documentclass=).
4) Replace =\date= with =\date{Modified: 21 October, 2013. Compiled: \today}=
5) Eventually search for all problems with =texttt=, i.e. search for pattern ="==.

Note: use =:ravel= followed by the properties for the code chunk headers, e.g. =:ravel results='hide'=. Other options for knitr style options are:
+ =results=: ='hide'= (hides all output, not warnings or messages), ='asis'=, ='markup'= (the default).
+ =warning=: =TRUE= or =FALSE= whether warnings should be displayed.
+ =message=: =TRUE= or =FALSE=, same as above.
+ =include=: =TRUE= or =FALSE=, whether the output should be included into the final document (code is still evaluated).

* Introduction

This package provides basic pedigree analysis and plotting utilities as well as
a variety of methods to evaluate familial clustering of cases from a given
trait. Identification of families or groups of individuals within families with
significant aggregation of cases can aid also in the selection of interesting
and promising individuals for whole genome or exome sequencing projects.


* Basic pedigree operations

In the examples below we perform some simple pedigree operations, such as
plotting the pedigree for an individual or family, finding the closest common
ancestor for a set of individuals in a pedigree or retrieving the identifiers
(IDs) of all ancestors for an individual.
Basic pedigree information is stored in =FAData= objects, thus we first generate
such an object from a subset of the Minnesota Breast Cancer Study provided by
the =kinship2= package.

#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  library(FamAgg)

  data(minnbreast)
  ## Subsetting to only few families of the whole data set.
  mbsub <- minnbreast[minnbreast$famid %in% 4:14, ]
  mbped <- mbsub[, c("famid", "id", "fatherid", "motherid", "sex")]
  ## Renaming column names.
  colnames(mbped) <- c("family", "id", "father", "mother", "sex")
  ## Defining the optional argument age.
  endage <- mbsub$endage
  names(endage) <- mbsub$id
  ## Create the object.
  fad <- FAData(pedigree=mbped, age=endage)
#+END_SRC

We can access all the pedigree information stored in this object using the
=pedigree= method, but also using =$=. The row names of the pedigree
=data.frame= as well as the names of the vectors returned by =$= are the IDs of
the individuals in the pedigree.

#+BEGIN_SRC R
  ## Use the pedigree method to access the full pedigree
  ## data.frame,
  head(pedigree(fad))

  ## or access individual columns using $.
  ## The ID of the father (0 representing "founders"):
  head(fad$father)
  ## Mother:
  head(fad$mother)
  ## Sex:
  head(fad$sex)

  ## We can also access the age of each individual, if
  ## provided.
  head(age(fad))
#+END_SRC

To extract the pedigree for a single family we can use the =family= method,
specifying either the ID of the family or the ID of an individual in the family.

#+BEGIN_SRC R
  ## Extract the pedigree information from family "4"...
  nrow(family(fad, family=4))

  head(family(fad, family=4))

  ## ...which is the same as extracting the family pedigree
  ## for an individual of this family.
  head(family(fad, id=3))

  ## Note that IDs are internally always converted to character,
  ## thus, using id=3 and id="3" return the same information.
  head(family(fad, id="3"))
#+END_SRC

Alternatively, we could subset the =FAData= to individuals of a single family.

#+BEGIN_SRC R
  ## Subset the object to a single family.
  fam4 <- fad[fad$family == "4", ]
  table(fam4$family)
#+END_SRC

To explore this family we can plot its pedigree. By default, the plotting
capabilities of the =kinship2= package are used to plot pedigrees, but
alternatively, if all required dependencies are available, the =HaploPainter=
\cite{Thiele:2005} perl script (http://haplopainter.sourceforge.net/) can be
used instead. The =switchPlotfun= function can be used to switch the plotting
back-end. Available arguments are =ks2paint= and =haplopaint= for =kinship2=
and =HaploPainter= plotting, respectively. Note however, that =HaploPainter=
only allows to export plots to a file, while =kinship2= plotting allows, in
addition to export the plot, also to show it as a /standard/ =R= plot.

Below we use the =switchPlotfun= to ensure the use of =kinship2= plotting
(usually not required) and plot the full available pedigree of individual =3=.
If the age of individuals is available, it will be plotted below the
individual's ID.

#+BEGIN_SRC R :ravel family-4-pedigree, message=FALSE, fig.align='center'
  switchPlotfun("ks2paint")
  ## By supplying device="plot", we specify that we wish to visualize the
  ## pedigree in an R plot. This is the default for "ks2paint", anyway.
  plotPed(fad, id=3, device="plot")
#+END_SRC

The pedigree for an individual or a list of individuals can be extracted using
the =buildPed= method. By default the method first tries to identify all parents
up to 3 generations in the pedigree, and subsequently all children of the
individuals and all identified parents.

#+BEGIN_SRC R
  ## Build the pedigree for individual 3.
  fullPed <- buildPed(fad, id="3")
  nrow(fullPed)
#+END_SRC

Alternatively, we can extract the smallest possible pedigree for a list of
individuals by specifying =prune=TRUE=. Internally, the function transforms the
pedigree into a graph, tries to find all paths between the individuals and
returns the sub-graph of all individuals along with individuals along the paths
between them.

#+BEGIN_SRC R
  ## Find the subpedigree for individuals 21, 22 and 17.
  buildPed(fad, id=c(21, 22, 17), prune=TRUE)
#+END_SRC

And the pedigree plot for that subset of the whole family:

#+BEGIN_SRC R :ravel family-sub-pedigree, message=FALSE, fig.align='center'
  plotPed(fad, id=c(21, 22, 17), prune=TRUE)
#+END_SRC

Note that the pedigree returned by the =buildPed= method for an individual might
be different than the pedigree of a whole family. The pedigree returned by
=buildPed= contains only individuals that share kinship with the specified
individual. To exemplify this, we plot the pedigree for the family =14= in the
Minnesota Breast Cancer data set. Note that the individuals in the pedigree plot
depicted as diamonds are individuals with unknown gender. (The message
"Did not plot..." is issued by the =kinship2= plotting function and indicates
singletons that are assigned to the family but do neither have parents nor
children.)

#+BEGIN_SRC R :ravel pedigree-family-14, message=FALSE, fig.align='center'
  plotPed(fad, family="14", cex=0.4)
#+END_SRC

In this family, founder =441= is the founder of two family branches. Building
the pedigree for individual =440= will not include any of the individuals of the
second branch, as he does not share kinship with any of them. The pedigree built
for =447= on the other hand contains also individuals from the second branch as
she shares kinship with them (/via/ her mother =441=).

#+BEGIN_SRC R
  ## Check if we have individual 26064 from the second branch in the pedigree
  ## of individual 440.
  any(buildPed(fad, id="440")$id == "26064")

  ## What for the pedigree of 447?
  any(buildPed(fad, id="447")$id == "26064")
#+END_SRC


A family pedigree may consist of many founder couples (i.e. individuals for
which neither father nor mother is defined in the pedigree). To identify the
pedigree's founder couple (being the couple with the largest number of offspring
generations in the pedigree) the =findFounders= method can be used. Note that
the function returns always only one couple, even if there might be two founder
couples in the family pedigree with the same number of offspring generations.

#+BEGIN_SRC R
  ## Find founders for family 4.
  findFounders(fad, "4")
#+END_SRC

Alternatively, it might be of interest to determine the closest common ancestor
between individuals in a pedigree. Below we use the =getCommonAncestor= method
to identify the common ancestor for individuals =21=, =22= and =17= (which we
know from the pedigree a bit above are =1= and =2=).

#+BEGIN_SRC R
  ## Find the closest common ancestor.
  getCommonAncestor(fad, id=c(21, 22, 17))
#+END_SRC

Other useful methods are =getChildren=, =getAncestors= and =getSiblings=, that
return the children (or all offspring generations up to a specified level), the
parents (or all ancestors) or the siblings for the specified individuals,
respectively.

#+BEGIN_SRC R
  ## Get the children of ID 4.
  getChildren(fad, id="4", max.generations=1)

  ## Get the offspring.
  getChildren(fad, id="4")

  ## Get all ancestors.
  getAncestors(fad, id="4")

  ## Get the siblings.
  getSiblings(fad, id=c("4"))
#+END_SRC

In the whole Minnesota Breast Cancer data set there are 426 families
corresponding to 426 founders that had cancer during the screening phase between
1944 and 1952.
In the code block below we identify the affected founders per family.

#+BEGIN_SRC R
  ## Add the trait information to the FAData object.
  cancer <- mbsub$cancer
  names(cancer) <- as.character(mbsub$id)
  trait(fad) <- cancer

  ## Identify the affected founders:
  ## First all affected individuals:
  affIds <- affectedIndividuals(fad)
  ## Identify founders for each family:
  founders <- lapply(unique(fad$family), function(z){
      return(findFounders(fad, family=z))
  })
  names(founders) <- unique(fad$family)

  ## Track the affected founder:
  affFounders <- lapply(founders, function(z){
      return(z[z %in% affIds])
  })
  ## Interestingly, not all founders are affected! It seems in some cases
  ## parents of the affected participants in the screening phase have also
  ## been included.
  affFounders <- affFounders[unlist(lapply(affFounders, length)) > 0]

  ## The number of families analyzed:
  length(founders)

  ## The number of families with affected founder:
  length(affFounders)

#+END_SRC

Unexpectedly, only in few families one of the founders is affected. For the
other families additional (unaffected) ancestors might have been added at a
later time point.

Next we get the number of affected individuals that are related to these
affected founders.

#+BEGIN_SRC R
  kin2affFounders <- shareKinship(fad, unlist(affFounders))

  ## How many of these are affected?
  sum(kin2affFounders %in% affIds)

  ## How many affected are not related to an affected founder?
  sum(!(affIds %in% kin2affFounders))

#+END_SRC

** Pedigree analysis methods

In this section we perform some more advanced pedigree operations.
First we identify all individuals in the pedigree that share kinship with
individual =4=.

#+BEGIN_SRC R
  ## Get all individuals sharing kinship with individual 4.
  shareKinship(fad, id="4")
#+END_SRC

Next we determine generations within the pedigree. Generations can only be
estimated for a single family, since in most instances e.g. the year of birth is
not available. Thus, generations are estimated considering the relation between
individuals, starting from the founder couple, i.e. generation 0, assigning
generation 1 to their children and all the mates of their children and so
on. The =estimateGenerations= method calculates such generation numbers for each
family defined in the object (or for a single family, if the family ID is
provided). The result is returned as a list with the list names corresponding to
the family ID and the list elements being the estimated generation numbers
(with names corresponding to the ID of the respective individual).

#+BEGIN_SRC R
  ## Estimate generation levels for all families.
  estimateGenerations(fad)[1:3]
#+END_SRC

Individuals without generation level (i.e. with an =NA=) are not connected to
any other individual in the pedigree (and thus most likely represent errors in
the pedigree).

In addition, it is also possible to calculate generation levels relative to a
(single) specified individual:

#+BEGIN_SRC R
  gens <- generationsFrom(fad, id="4")
#+END_SRC

We can draw these generation numbers into the pedigree:

#+BEGIN_SRC R :ravel family-four-gens-rel-to-four, message=FALSE, fig.align='center'
  plotPed(fad, family=4, label2=gens)
#+END_SRC



** Additional plotting options

If a trait information is available it might be of interest to highlight
affected individuals in the pedigree. Trait information should always be coded
as =0= (or =FALSE=) for unaffected and =1= (or =TRUE=) for affected. In the
example below we use the /cancer/ information from the Minnesota Breast Cancer
Study.

#+BEGIN_SRC R :results silent :ravel results='hide', message=FALSE
  ## Extract the cancer trait information.
  tcancer <- mbsub$cancer
  names(tcancer) <- mbsub$id
  ## Set the trait.
  trait(fad) <- tcancer

#+END_SRC

We can now extract the trait information from the object or identify directly
the phenotyped or affected individuals.

#+BEGIN_SRC R
  ## Extract the trait information.
  head(trait(fad))

  ## We can also extract the IDs of the affected individuals.
  head(affectedIndividuals(fad))

  ## Or the IDs of the phenotyped individuals.
  head(phenotypedIndividuals(fad))
#+END_SRC

Plotting a =FAData= object with trait information results in a pedigree plot
with highlighted affected individuals (for =kinship2= pedigree plotting:
affected, unaffected and not phenotyped are represented as filled symbols, open
symbols and symbols with a question mark inside, respectively).

#+BEGIN_SRC R :ravel family-pedigree-affected, message=FALSE, fig.align='center'
  ## Plotting the pedigree for family "9".
  plotPed(fad, family="9")
#+END_SRC

In addition we can manually highlight individuals using the =highlight.ids=
argument. For =kinship2= pedigree plotting, a list of length 2 is supported as
argument =highlight.ids=, with the first element being plotted on the top left
corner of the symbol and the second element on the top right corner.

#+BEGIN_SRC R :ravel family-pedigree-affected-highlighted, message=FALSE, fig.align='center'
  ## Plotting the pedigree for family "9".
  plotPed(fad, family="9", highlight.ids=list(a=c("185", "201", "198"),
                                              b=c("193")))
#+END_SRC

An alternative way to highlight individuals or add text to the plot is to use
the arguments =label1=, =label2= and =label3= or the =plotPed= method.


** Graph utilities

Pedigrees can also be transformed to graphs using the =ped2graph= function. That
way all graph theory methods implemented in e.g. the =igraph= package can be
applied to pedigrees.

#+BEGIN_SRC R
  ## Transform the full pedigree to a graph.
  fullGraph <- ped2graph(pedigree(fad))

  ## In addition build the graph for a single family.
  singleFam <- ped2graph(family(fad, family=4))
#+END_SRC

We can plot these pedigrees also as graph and could use any of the layout
methods provided in the =igraph= package.

#+BEGIN_SRC R :ravel graph-plots, fig.align='center'
  ## Build the layout.
  plot(fullGraph)
  lay <- layout_(singleFam, on_grid())
  plot(singleFam, layout=lay)
#+END_SRC


The =connectedSubgraph= function implemented in the =FamAgg= package provides
additional functionality to find the smallest connected subgraph of a list of
submitted nodes (i.e. individuals).

In the code below we want to extract the smallest possible connected subgraph of
the pedigree-graph of family 4 containing individuals =7=, =8=, =27= and =17=.

#+BEGIN_SRC R
  subgr <- connectedSubgraph(singleFam, nodes=c("7", "8", "27", "17"))
#+END_SRC

This is in principle what the =buildPed= method with the option =prune=TRUE=
does to find the smallest pedigree for a set of individuals, only that
=buildPed= ensures that also eventually missing parents are added.

#+BEGIN_SRC R :ravel subgraph-plot, fig.align='center'
  ## Plot the graph.
  plot(subgr)
  ## Similar to buildPed/plotPed with prune=TRUE.
  plotPed(fad, id=c("7", "8", "17", "27"), prune=TRUE)
#+END_SRC


* Testing for familial aggregation

Familial aggregation aims to identify families within large ancestral
pedigrees that show a non-random aggregation of traits.  One such method to
test if a disease is clustered in families is the /genealogical index/
\cite{Hill:1980tz}. For a given trait (e.g. whether or not an individual was
diagnosed with a certain type of cancer), the method computes the mean kinship
between affected individuals (cases) in the whole pedigree along with mean
kinship values of randomly drawn sets of individuals. The distribution of
average kinship values among the control sets is then used to estimate the
probability that the observed level of kinship among the cases is due to
chance.

We next calculate the genealogical index for cancer occurrence in a subset of
the Minnesota Breast Cancer Record data set. We first generate the appropriate
=FAData= object containing the pedigree and perform the analysis using the
=genealogicalIndexTest= method on the =cancer= trait in which cases of breast or
prostate cancer are reported.  In its default setting the =genealogicalIndexTest=
function uses all phenotyped individuals in the pedigree as control population
from which sets of random samples equal in size to the number of affected are
drawn.

Note that, to reduce computation time, we perform the analysis only on a subset
of families from the Minnesota Breast Cancer record and reduce the number of
simulation runs. We specifically selected some families with a high percentage
of cancer cases, thus, the analysis presented here is biased.


#+BEGIN_SRC R :ravel warning=TRUE, message=FALSE
  data(minnbreast)
  ## Subset the dataset to reduce processing time.
  mbsub <- minnbreast[minnbreast$famid %in% c(4:60, 432), ]
  ## Use the whole dataset instead:
  ## mbsub <- minnbreast

  ## Define the number of simulations we perform.
  ## nsim <- 50000
  nsim <- 400

  mbped <- mbsub[, c("famid", "id", "fatherid", "motherid", "sex")]
  ## Renaming column names.
  colnames(mbped) <- c("family", "id", "father", "mother", "sex")
  ## Create the FAData object.
  fad <- FAData(pedigree=mbped)

  ## Define the trait.
  tcancer <- mbsub$cancer
  names(tcancer) <- as.character(mbsub$id)
  ## Calculate the genealogical index:
  gi <- genealogicalIndexTest(fad, trait=tcancer, traitName="cancer", nsim=nsim)

  ## Display the result:
  result(gi)
#+END_SRC

Thus, according to the genealogical index test, a clustering of cancer cases is
present in the analyzed pedigree. The warning messages just indicate that some
individuals have been excluded from the test since they were either not phenotyped
in the trait (i.e. have a missing value in trait), or are not /connected/ in the
family pedigree (do not share kinship with any other individual in the pedigree
after removing non-phenotyped individuals).

The genealogical index implementation in this package adds some more flexibility
to the original approach. The definition of the appropriate set of control
individuals from which random samples are drawn can be specified with the
=controlSetMethod= argument. Also, it is possible to perform a stratified
sampling, e.g. if the group of affected cases in a pedigree consists of 5
female and 3 male individuals, submitting the sex of each individual in the
pedigree with the argument =strata= (i.e. =strata=fad$sex=, with =fad= being the
=FAData= object on which the analysis is performed) allows the function to
define random control sets with the same proportion of male/female individuals.

In the next example we use the =getSexMatched= function to define the set of
control individuals and also the =getExternalMatched= submitting the gender
information of each individual. The results from both approaches are essentially
identical, and in the present data set not that useful, as the Minnesota Breast
Cancer data set lists both, breast cancer and prostate cancer in column
=cancer=, thus, the set of control individuals will contain all individuals with
known sex.

#+BEGIN_SRC R :ravel warning=FALSE, eval=FALSE
  ## Calculate the genealogical index using random sampling from a sex matched control set.
  giSexMatch <- genealogicalIndexTest(fad, trait=tcancer, traitName="cancer", nsim=nsim,
                                  controlSetMethod="getSexMatched")

  ## Use an external vector to perform the matching. The results are essentially identical.
  giExtMatch <- genealogicalIndexTest(fad, trait=tcancer, traitName="cancer", nsim=nsim,
                                  controlSetMethod="getExternalMatched", match.using=fad$sex)
#+END_SRC

Note that any matching or stratified sampling can lead to the exclusion of
individuals with missing values in either the matching criteria or the strata.

In the Minnesota Breast Cancer data set, the number of prostate cancer cases is
much lower than the number of breast cancer cases, thus, simple random sampling
might result in an biased genealogical index estimate since about the same
proportion of male and female individuals will be sampled. To account for such
cases a stratified sampling, as performed below, can be used instead.

#+BEGIN_SRC R :ravel warning=FALSE
  ## Evaluate the proportion of male and femal cases.
  table(gi$sex[affectedIndividuals(gi)])

  ## We can use the gender information to perform stratified sampling, i.e.
  ## in each permutation a random set of 3 male and 15 females will be selected.
  giStrata <- genealogicalIndexTest(fad, trait=tcancer, traitName="cancer", nsim=nsim,
                                strata=fad$sex)

  result(giStrata)
#+END_SRC

At last we plot the result from the simulation. The blue vertical line in the
plot below represents the mean kinship value between all affected in the
pedigree. The distribution of mean kinship values from the 1000 randomly drawn
sets are shown in grey color.

#+BEGIN_SRC R :ravel mbreast-genealogical-index-result, message=FALSE, warning=FALSE, fig.align='center'
  ## Plot the result.
  plotRes(giStrata)
#+END_SRC

In the example above we tested for an enrichment of cancer cases in the full
data set, i.e. across all families. In addition we could however also perform
the test individually for each family, by setting the =perFamilyTest= parameter
of the =genealogicalIndexTest= to =TRUE=, and thus test for a clustering of cancer
cases within each family.


# The FR from Kerber
A per-individual risk of e.g. disease can be calculated using the /familial
incidence rate/ (FR) \cite{Kerber:1995cx}. This measure considers the kinship of each
individual with any affected in a given trait in the pedigree and the time at
risk for each individual. Thus, the FR is an estimate for the risk per gene-time
for each individual given the disease-experience in the cohort.

As /time at risk/ for each individual we use the /endage/ column in the
Minnesota Breast Cancer data set, that represents the participant's age at the
last follow-up or at cancer incidence. This estimate of time at risk is rather
crude and in a real life situation a better, more accurate, estimate that bases
e.g. on the birth dates and dates of last follow up or incidence might be used
instead. See the help of functions =estimateTimeAtRisk= and =sliceAge= for
details and options related to /time at risk/.

#+BEGIN_SRC R :ravel warning=FALSE
  ## Estimate the risk for each individual using the familial incidence rate method.
  ## We use the endage provided in the minnesota breast cancer record as
  ## a measure for time at risk.
  fr <- familialIncidenceRate(fad, trait=tcancer, timeAtRisk=mbsub$endage)

  ## Extracting the actual FR values; the analysis was performed on the
  ## complete pedigree and the results are thus present in the first
  ## element of the list.
  fr <- fr[[1]]
#+END_SRC

Next we calculate the mean FR within each family and plot this information.

#+BEGIN_SRC R :ravel mbreast-mean-fr-per-family, message=FALSE, warning=FALSE, fig.align='center'
  ## Split the FR by family and average the values within each.
  frFam <- split(fr, f=fad$family)
  frFamAvg <- lapply(frFam, mean, na.rm=TRUE)

  ## Sort and plot the averages.
  frFamAvg <- sort(unlist(frFamAvg), decreasing=TRUE)
  plot(frFamAvg, type="h", xaxt="n", xlab="", ylab="mean FR",
       main="Per family averaged familial incidence rate")
  axis(side=1, las=2, at=1:length(frFamAvg), label=names(frFamAvg))

#+END_SRC

Not unexpectedly, individuals in some families have on average a higher familial
incidence rate, and thus a higher risk of cancer than others.

# The kinship sum test; compare significant individuals to high FR.
Next we use the /kinship sum test/ that evaluates familial aggregation based
on the sum of kinship values between affected cases. The test identifies
affected individuals exhibiting a higher relationship to other affected
individuals than would be expected by chance. By specifying the =strata= we
perform sex-stratified random sampling, i.e. ensure that the proportion of male
and female individuals in each randomly sampled group matches the corresponding
proportions in the /real/, observed, affected.

#+BEGIN_SRC R
  ## Perform the kinship sum test.
  kinSum <- kinshipSumTest(fad, trait=tcancer, traitName="cancer",
                             nsim=nsim, strata=fad$sex)
  head(result(kinSum))

#+END_SRC

The warning messages above indicate that for some individuals in the pedigree no
gender information is provided. These individuals have to be excluded from the
stratified random sampling.

Next we identify those individuals that have a significant kinship sum accepting
a 10% false discovery rate (FDR).

#+BEGIN_SRC R
  ## Extract the IDs of the individuals with significant kinship. By default, the raw p-values
  ## are adjusted for multiple hypothesis testing using the method from Benjamini and Hochberg
  kinSumRes <- result(kinSum)
  kinSumIds <- as.character(kinSumRes[kinSumRes$padj < 0.1, "affected_id"])

  ## From which families are these?
  table(kinSumRes[kinSumIds, "family"])
#+END_SRC

Thus, most of the identified significant individuals are from one family.
Next we compare the above calculated FR scores of affected or unaffected (but
phenotyped) individuals in this family to the FR scores of affected or
unaffected individuals of all other families.

#+BEGIN_SRC R :ravel mbreast-family-432-FR-compared-to-others, message=FALSE, warning=FALSE, fig.align='center'
  ## Get the familial ratio of the significant in this family, of all in this family,
  ## and of all others.
  famId <- kinSumRes[1, "family"]

  ## Extract the family:
  fam <- family(kinSum, family=famId)

  ## Stratify individuals in affected/unaffected
  strat <- rep("All, unaff.", length(kinSum$id))
  strat[which(kinSum$affected > 0)] <- "All, aff."
  strat[kinSum$id %in% fam$id] <- paste0("Fam ", famId, ", unaff.")
  strat[kinSum$id %in% fam$id[which(fam$affected > 0)]] <- paste0("Fam ",
                                                                  famId,
                                                                  ", aff.")

  famData <- data.frame(fr=fr, group=strat)
  boxplot(fr~group, data=famData, na.rm=TRUE, ylab="FR",
          col=rep(c("#FBB4AE", "#B3CDE3"), 2))

#+END_SRC

As expected, the familial incidence rate (i.e., in the present data set, the
risk of individuals to get cancer, given their kinship to other cancer cases)
for individuals (whether affected or yet unaffected) in this family is higher
than in the data set analyzed here.

Next we plot the pedigree of this family.

#+BEGIN_SRC R :ravel mbreast-family-432-affected, message=FALSE, warning=FALSE, fig.align='center'
  ## Plot the pedigree for the family of the selected individual removing
  ## all individuals that were not phenotypes.
  plotPed(kinSum, id=kinSumIds[1], cex=0.3, only.phenotyped=TRUE)


#+END_SRC

And, at last also the kinship sum for the individuals with the largest kinship
sum in relation to the /expected/ kinship sums from the Monte Carlo simulations.

#+BEGIN_SRC R :ravel mbreast-family-432-affecte-res, message=FALSE, warning=FALSE, fig.align='center'
  plotRes(kinSum, id=kinSumIds[1])
#+END_SRC

# The kinship group test (Daniel).
Another test to identify familial aggregation is the /kinship group test/. This
test first defines for each affected a group of individuals considering only
individuals that are as closely related as the most distant affected individual.
For each of these kinship groups two tests are then performed, one by comparing
the mean kinship among affected in the group with the mean kinship from Monte
Carlo simulations (ratio test) and one evaluating the largest observed kinship
value between affected individuals with those of random samples from the
simulation (kinship group test).

Below we perform the kinship group test for the Minnesota Breast Cancer data
set. Again we specify the =strata= argument and thus perform sex-stratified
random sampling.

#+BEGIN_SRC R
  ## Calculate the kinship test.
  kinGroup <- kinshipGroupTest(fad, trait=tcancer, traitName="cancer",
                               nsim=nsim, strata=fad$sex)
  head(result(kinGroup))

#+END_SRC

Also the kinship group test finds a significant aggregation of cases in
family 432. In fact, as we see further below, the test identified a subgroup in
this family with an exceptional high proportion of cases.

Below we summarize the results further by listing the total number of families
in the pedigree and the number of families in which kinship groups with
significant kinship p-value and significant ratio p-value (both at a 5% FDR).

#+BEGIN_SRC R
  kinGroupRes <- result(kinGroup)
  ## Creating a data.frame with the summarized results.
  resTab <- data.frame(total_families=length(unique(kinGroup$family)),
                       ratio_sign=length(unique(
                           kinGroupRes[kinGroupRes$ratio_padj < 0.05, "family"]
                       )),
                       kinship_sign=length(unique(
                           kinGroupRes[kinGroupRes$kinship_padj < 0.05, "family"]
                       ))
                       )
  resTab
#+END_SRC

The most significant kinship group which was identified by the kinship group
test is shown in the figure below. The mother (individual =17609=) in this group
and all her daughters have cancer, the mother is however not directly related to
the affected founder of this family (individual =17517= of family =432=, see
figure above for the full pedigree of this family).
We are also submitting the familial incidence ratio values calculated above with
argument =label1= which are then displayed below the ID of each individual in
the plot.

#+BEGIN_SRC R :ravel mbreast-family-432-affecte-res-kinship, message=FALSE, warning=FALSE, fig.align='center'
  plotPed(kinGroup, id=kinGroupRes[kinGroupRes$family == "432", "group_id"][1],
          prune=TRUE, label1=fr)
#+END_SRC

** Familial standardized incidence ratio 			   :noexport:

The familial standardized incidence ration (FSIR) \cite{Kerber:1995cx} weights
the disease status of relatives based on their degree of relatedness with the
proband. Formally, the FSIR is defined as the standardized incidence ratio (SIR)
or standardized mortality ratio \cite{Breslow:1987wc} in epidemiology, i.e. as
the ratio between the number of cases by the /expected/ number of casee, only
that both, observed and expected cases are in addition also weighted by the
degree of relatedness (i.e. kinship value) between individuals in the pedigree.


* TODOs								   :noexport:

** CANCELED Find a way to calculate the pedigree size.
   CLOSED: [2015-08-24 Mon 08:18]
   - State "CANCELED"   from "TODO"       [2015-08-24 Mon 08:18] \\
     Don't think I need that at all...
+ [ ] include in =result= for =FAProbResult=.
+ [ ] include in =result= for =FAKinshipResult=.
** DONE Include the php script. [2/2]
   CLOSED: [2015-07-23 Thu 10:43]
   - State "DONE"       from "TODO"       [2015-07-23 Thu 10:43]
+ [X] Locate the script and include it into the package.
+ [X] Check what we can use from that script and whether it might not be better
  to re-implement it!


** CANCELED Include the plotting script. [1/1]
   CLOSED: [2015-09-16 Wed 11:01]
   - State "CANCELED"   from "TODO"       [2015-09-16 Wed 11:01] \\
     In the meantime we excluded it again...
+ [X] Locate the script and include it into the package.


** DONE Generate unit tests: [5/5]
   CLOSED: [2015-09-16 Wed 11:00]
   - State "DONE"       from "TODO"       [2015-09-16 Wed 11:00]
+ [X] FAData.
+ [X] FAResult.
+ [X] FAKinClustResult.
+ [X] FAKinshipResult.
+ [X] FAProbResult.

** DONE Remove the CHRIS data and the =test_validate_new.R= test script.
   CLOSED: [2015-09-18 Fri 13:47]
   - State "DONE"       from "TODO"       [2015-09-18 Fri 13:47]
** CANCELED Implement a method =plotPedForId= for =FAResult=.
   CLOSED: [2015-07-27 Mon 10:43]
   - State "CANCELED"   from "TODO"       [2015-07-27 Mon 10:43] \\
     implemented plotPed instead.
+ add a 1 to =is.proband= for the current id.
+ add the age (if available) at the bottim (=text.below.symbol=).
+ add an r to =text.in.symbol= for those that are related to the current
  individual (i.e. have kinship larger 0) with the proband and were phenotyped.

** CANCELED Implement a method =plotPedForFam= for =FAResult=.
   CLOSED: [2015-07-27 Mon 10:44]
   - State "CANCELED"   from "TODO"       [2015-07-27 Mon 10:44] \\
     Implemented plotPed instead.
** DONE =plotPed= for =FAData=
   CLOSED: [2015-07-23 Thu 10:45]
   - State "DONE"       from "TODO"       [2015-07-23 Thu 10:45]
   - plots for id or full family.
** DONE =plotPed= for =FAResult=
   CLOSED: [2015-07-23 Thu 10:45]
   - State "DONE"       from "TODO"       [2015-07-23 Thu 10:45]
   - calls the =FAData= method.
** DONE =plotPed= for =FAKinClustResult=
   CLOSED: [2015-07-23 Thu 10:45]
   - State "DONE"       from "TODO"       [2015-07-23 Thu 10:45]
   - Plots are the same as in the original php version.
** DONE =plotPed= for =FAKinshipResult=
   CLOSED: [2015-08-17 Mon 11:47]
   - State "DONE"       from "TODO"       [2015-08-17 Mon 11:47]
- A little tricky, since we can't make it working as the php version (does that
  make sense anyway?).
- plots the full pedigree for an id and highlights those included in the test.

** DONE =plotPed= for =FAProbabilityResult=
   CLOSED: [2015-08-17 Mon 11:47]
   - State "DONE"       from "TODO"       [2015-08-17 Mon 11:47]
** DONE Implement a =prune= option for =plotPed= on =FAKinshipResult= and =FAProbResult= [2/2]
   CLOSED: [2015-08-17 Mon 11:47]
   - State "DONE"       from "TODO"       [2015-08-17 Mon 11:47]
+ [X] =FAKinshipResult=.
+ [X] =FAProbResult=.


** DONE Documentation [6/6]:
   CLOSED: [2015-08-17 Mon 11:47]
   - State "DONE"       from "TODO"       [2015-08-17 Mon 11:47]
+ [X] =FAData=.
+ [X] =FAResult=.
+ [X] =FAKinClustResult=.
+ [X] =FAKinshipResult=.
+ [X] =FAProbResult=.
+ [X] Pedigree Utility functions (=ped2graph= etc.).
  - =subPedigree=.
  - =ped2graph=.

** DONE Implement the plotting function based on =kinship2= to show the same info as HaploPainter.
   CLOSED: [2015-08-24 Mon 08:18]
   - State "DONE"       from "TODO"       [2015-08-24 Mon 08:18]
+ [X] First argument is proband.
+ [X] Second affected.



** DONE Clean the test cases from any code referring to CHRIS data
   CLOSED: [2015-09-16 Wed 11:01]
   - State "DONE"       from "TODO"       [2015-09-16 Wed 11:01]
+ Move the evaluation code (comparison with original code) to some =notrun_=
  functions in a separate test file.

** DONE Implement a =[= method to subset.
   CLOSED: [2015-08-21 Fri 14:08]
   - State "DONE"       from "TODO"       [2015-08-21 Fri 14:08]
** DONE Re-evaluate: what with affected status =NA=
   CLOSED: [2015-08-24 Mon 08:18]
   - State "DONE"       from "TODO"       [2015-08-24 Mon 08:18]
- =ks2paint=: affected being NA are replaced by 0! FIXED!
- haplopaint?



** DONE Implement the Hill method significant over-representation of a disease in a family
   CLOSED: [2015-09-16 Wed 11:01]
   - State "DONE"       from "TODO"       [2015-09-16 Wed 11:01]
+ Method from Jon Rice Hill \cite{Hill:1980tz}.
+ Approach (chapter 4): compare the mean kinship of affected in a pedigree (same family!) to
  the distribution of mean kinships of random control groups.
  - Works only within a family.
  - Calculate mean kinship of the affected.
  - Randomly select x times the same number of cases from the control
    population, calculate mean for each and generate that way the background
    distribution.

+ Implement:
  - [X] Method: =matchedControlGroup=, takes IDs as input and returns a vector
    of IDs of suitable controls, matching them by generation,
  - [X] Method: =sampleMatchedControls=: randomly samples IDs from the matched
    controls, considering also the probability for sex.


** TODO Implement the Kerber method.

** DONE Implement =plotRes= method for =FAKinClustResult=.
   CLOSED: [2015-09-18 Fri 13:45]
   - State "DONE"       from "TODO"       [2015-09-18 Fri 13:45]
** DONE Implement =plotRes= method for =FAKinshipResult=.
   CLOSED: [2015-09-18 Fri 13:45]
   - State "DONE"       from "TODO"       [2015-09-18 Fri 13:45]
** CANCELED Implement =plotRes= method for =FAProbResult=.
   CLOSED: [2015-09-18 Fri 13:46]
   - State "CANCELED"   from "TODO"       [2015-09-18 Fri 13:46] \\
     No way to do that...
** DONE Implement strata sampling for =FAKinClustResult=.
   CLOSED: [2015-09-21 Mon 13:40]
   - State "DONE"       from "TODO"       [2015-09-21 Mon 13:40]
** DONE Check/update the help page for =FAProbResult=
   CLOSED: [2015-09-21 Mon 13:41]
   - State "DONE"       from "TODO"       [2015-09-21 Mon 13:41]
** DONE Implement strata sampling for =FAKinGroupResults=
   CLOSED: [2015-10-09 Fri 06:58]
   - State "DONE"       from "TODO"       [2015-10-09 Fri 06:58]
** DONE Remove the obsolete =FAResult= object.
   CLOSED: [2015-09-22 Tue 15:20]
   - State "DONE"       from "TODO"       [2015-09-22 Tue 15:20]


** DONE Rename =FAKinshipResult= into =FAKinGroup=
   CLOSED: [2015-09-23 Wed 07:20]
   - State "DONE"       from "TODO"       [2015-09-23 Wed 07:20]
** DONE Rename =FAKinClustResult= into =FAKinSum=
   CLOSED: [2015-09-23 Wed 07:20]
   - State "DONE"       from "TODO"       [2015-09-23 Wed 07:20]
* References
