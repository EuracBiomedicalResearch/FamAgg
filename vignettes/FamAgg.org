#+TITLE: Pedigree Analysis and Familial Aggregation
#+AUTHOR:    Johannes Rainer, Daniel Taliun, Christian X. Weichenberger
#+EMAIL:     johannes.rainer@eurac.edu
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS: ^:{} toc:nil
#+PROPERTY: exports code
#+PROPERTY: session *R*

#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

#+BEGIN_EXPORT html
---
title: "Pedigree Analysis and Familial Aggregation"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Pedigree Analysis and Familial Aggregation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{FamAgg}
  %\VignettePackage{FamAgg}
  %\VignetteKeywords{Genetics}
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---
#+END_EXPORT

#+BEGIN_EXPORT html
**Package**: `r Biocpkg("FamAgg")`<br />
**Authors**: `r packageDescription("FamAgg")$Author`<br />
**Modified**: `r file.info("FamAgg.Rmd")$mtime`<br />
**Compiled**: `r date()`
#+END_EXPORT

* How to export this to a =Rmd= vignette			   :noexport:

Use =ox-ravel= to export this file as an R markdown file (=C-c C-e m r=). That
way we don't need to edit the resulting =Rmd= file.

* How to export this to a =Rnw= vignette 			   :noexport:

*Note*: this is deprecated! Use the =Rmd= export instead!

Use =ox-ravel= from the =orgmode-accessories= package to export this file to a
=Rnw= file. After export edit the generated =Rnw= in the following way:

1) Delete all =\usepackage= commands.
2) Move the =<<style>>= code chunk before the =\begin{document}= and before
   =\author=.
3) Move all =%\Vignette...= lines at the start of the file (even before
   =\documentclass=).
4) Replace =\date= with =\date{Modified: 21 October, 2013. Compiled: \today}=
5) Eventually search for all problems with =texttt=, i.e. search for pattern
   ="==.

Note: use =:ravel= followed by the properties for the code chunk headers,
e.g. =:ravel results='hide'=. Other options for knitr style options are:
+ =results=: ='hide'= (hides all output, not warnings or messages), ='asis'=,
  ='markup'= (the default).
+ =warning=: =TRUE= or =FALSE= whether warnings should be displayed.
+ =message=: =TRUE= or =FALSE=, same as above.
+ =include=: =TRUE= or =FALSE=, whether the output should be included into the
  final document (code is still evaluated).

* Introduction

This package provides basic pedigree analysis and plotting utilities as well as
a variety of methods to evaluate familial clustering of cases from a given
trait. Identification of families or groups of individuals within families with
significant aggregation of cases can aid also in the selection of interesting
and promising individuals for whole genome or exome sequencing projects.

For kinship coefficient calculations and pedigree plotting the package relies
and extends the functionality of the =kinship2= package \cite{Sinnwell:2014kd}.

If you use this package please cite Rainer et al. \cite{Rainer:2016hk}.

* Basic pedigree operations

In the examples below we perform some simple pedigree operations, such as
plotting the pedigree for an individual or family, finding the closest common
ancestor for a set of individuals in a pedigree or retrieving the identifiers
(IDs) of all ancestors for an individual. Basic pedigree information is stored
in =FAData= objects, thus we first generate such an object from a subset of the
Minnesota Breast Cancer Study provided by the =kinship2= package. In the example
below, we generate the =FAData= providing a =data.frame= with the pedigree data,
alternatively, the pedigree information could be imported from a file (see
Section [[import.export]]).  Upon data set creation the kinship matrix (i.e. a
matrix containing the kinship coefficient between each pair of individuals in
the whole pedigree) is internally calculated using the functionality from the
=kinship2= package \cite{Sinnwell:2014kd}.

#+NAME: libraries
#+BEGIN_SRC R :ravel warning = FALSE, message = FALSE
  library(FamAgg)

  data(minnbreast)
  ## Subsetting to only few families of the whole data set.
  mbsub <- minnbreast[minnbreast$famid %in% 4:14, ]
  mbped <- mbsub[, c("famid", "id", "fatherid", "motherid", "sex")]
  ## Renaming column names.
  colnames(mbped) <- c("family", "id", "father", "mother", "sex")
  ## Defining the optional argument age.
  endage <- mbsub$endage
  names(endage) <- mbsub$id
  ## Create the object.
  fad <- FAData(pedigree = mbped, age = endage)
#+END_SRC

We can access all the pedigree information stored in this object using the
=pedigree= method, but also using =$=. The row names of the pedigree
=data.frame= as well as the names of the vectors returned by =$= are the IDs of
the individuals in the pedigree.

#+NAME: access-data
#+BEGIN_SRC R
  ## Use the pedigree method to access the full pedigree
  ## data.frame,
  head(pedigree(fad))

  ## or access individual columns using $.
  ## The ID of the father (0 representing "founders"):
  head(fad$father)
  ## Mother:
  head(fad$mother)
  ## Sex:
  head(fad$sex)

  ## We can also access the age of each individual, if
  ## provided.
  head(age(fad))
#+END_SRC

To extract the pedigree for a single family we can use the =family= method,
specifying either the ID of the family or the ID of an individual in the family.

#+NAME: family
#+BEGIN_SRC R
  ## Extract the pedigree information from family "4"...
  nrow(family(fad, family = 4))

  head(family(fad, family = 4))

  ## ...which is the same as extracting the family pedigree
  ## for an individual of this family.
  head(family(fad, id = 3))

  ## Note that IDs are internally always converted to character,
  ## thus, using id=3 and id="3" return the same information.
  head(family(fad, id = "3"))
#+END_SRC

Alternatively, we could subset the =FAData= to individuals of a single family.

#+NAME: subsetting
#+BEGIN_SRC R
  ## Subset the object to a single family.
  fam4 <- fad[fad$family == "4", ]
  table(fam4$family)
#+END_SRC

To explore this family we can plot its pedigree. By default, the plotting
capabilities of the =kinship2= package are used to plot pedigrees, but
alternatively, if all required dependencies are available, the =HaploPainter=
\cite{Thiele:2005} perl script (http://haplopainter.sourceforge.net/) can be
used instead. The =switchPlotfun= function can be used to switch the plotting
back-end. Available arguments are =ks2paint= and =haplopaint= for =kinship2= and
=HaploPainter= plotting, respectively. Note however, that =HaploPainter= only
allows to export plots to a file, while =kinship2= plotting allows, in addition
to export the plot, also to show it as a /standard/ =R= plot.

Below we use the =switchPlotfun= to ensure the use of =kinship2= plotting
(usually not required) and plot the full available pedigree of individual =3=.
If the age of individuals is available, it will be plotted below the
individual's ID.

#+NAME: plotPed
#+BEGIN_SRC R :ravel message=FALSE, fig.align='center', warning = FALSE
  switchPlotfun("ks2paint")
  ## By supplying device="plot", we specify that we wish to visualize the
  ## pedigree in an R plot. This is the default for "ks2paint", anyway.
  plotPed(fad, id = 3, device = "plot")
#+END_SRC

The pedigree for an individual or a list of individuals can be extracted using
the =buildPed= method. By default the method first tries to identify all parents
up to 3 generations in the pedigree, and subsequently all children of the
individuals and all identified parents.

#+NAME: buildPed
#+BEGIN_SRC R :ravel message = FALSE
  ## Build the pedigree for individual 3.
  fullPed <- buildPed(fad, id = "3")
  nrow(fullPed)
#+END_SRC

Alternatively, we can extract the smallest possible pedigree for a list of
individuals by specifying =prune=TRUE=. Internally, the function transforms the
pedigree into a graph, tries to find all paths between the individuals and
returns the sub-graph of all individuals along with individuals along the paths
between them.

#+NAME: buildPed-prune
#+BEGIN_SRC R :ravel message = FALSE
  ## Find the subpedigree for individuals 21, 22 and 17.
  buildPed(fad, id = c(21, 22, 17), prune = TRUE)
#+END_SRC

And the pedigree plot for that subset of the whole family:

#+NAME: plotPed-3ids
#+BEGIN_SRC R :ravel message=FALSE, fig.align='center', warning = FALSE
  plotPed(fad, id = c(21, 22, 17), prune = TRUE)
#+END_SRC

Note that the pedigree returned by the =buildPed= method for an individual might
be different than the pedigree of a whole family. The pedigree returned by
=buildPed= contains only individuals that share kinship with the specified
individual. To exemplify this, we plot the pedigree for the family =14= in the
Minnesota Breast Cancer data set. Note that the individuals in the pedigree plot
depicted as diamonds are individuals with unknown gender. (The message "Did not
plot..." is issued by the =kinship2= plotting function and indicates singletons
that are assigned to the family but do neither have parents nor children.)

#+NAME: plotPed-family-14
#+BEGIN_SRC R :ravel message=FALSE, fig.align='center', warning = FALSE
  plotPed(fad, family = "14", cex = 0.4)
#+END_SRC

In this family, founder =441= is the founder of two family branches. Building
the pedigree for individual =440= will not include any of the individuals of the
second branch, as he does not share kinship with any of them. The pedigree built
for =447= on the other hand contains also individuals from the second branch as
she shares kinship with them (/via/ her mother =441=).

#+NAME: buildPed-for-individual
#+BEGIN_SRC R :ravel message = FALSE
  ## Check if we have individual 26064 from the second branch in the pedigree
  ## of individual 440.
  any(buildPed(fad, id = "440")$id == "26064")

  ## What for the pedigree of 447?
  any(buildPed(fad, id = "447")$id == "26064")
#+END_SRC

A family pedigree may consist of many founder couples (i.e. individuals for
which neither father nor mother is defined in the pedigree). To identify the
pedigree's founder couple (being the couple with the largest number of offspring
generations in the pedigree) the =findFounders= method can be used. Note that
the function returns always only one couple, even if there might be two founder
couples in the family pedigree with the same number of offspring generations.

#+NAME: findFounders
#+BEGIN_SRC R :ravel message = FALSE
  ## Find founders for family 4.
  findFounders(fad, "4")
#+END_SRC

Alternatively, it might be of interest to determine the closest common ancestor
between individuals in a pedigree. Below we use the =getCommonAncestor= method
to identify the common ancestor for individuals =21=, =22= and =17= (which we
know from the pedigree a bit above are =1= and =2=).

#+NAME: getCommonAncestors
#+BEGIN_SRC R :ravel message = FALSE
  ## Find the closest common ancestor.
  getCommonAncestor(fad, id = c(21, 22, 17))
#+END_SRC

Other useful methods are =getChildren=, =getAncestors= and =getSiblings=, that
return the children (or all offspring generations up to a specified level), the
parents (or all ancestors) or the siblings for the specified individuals,
respectively.

#+NAME: getChildren-and-others
#+BEGIN_SRC R :ravel message = FALSE
  ## Get the children of ID 4.
  getChildren(fad, id = "4", max.generations = 1)

  ## Get the offsprings.
  getChildren(fad, id = "4")

  ## Get all ancestors.
  getAncestors(fad, id = "4")

  ## Get the siblings.
  getSiblings(fad, id = c("4"))
#+END_SRC

In the whole Minnesota Breast Cancer data set there are 426 families
corresponding to 426 founders that had cancer during the screening phase between
1944 and 1952. In the code block below we identify the affected founders per
family.

#+NAME: affected-founders
#+BEGIN_SRC R :ravel message = FALSE
  ## Add the trait information to the FAData object.
  cancer <- mbsub$cancer
  names(cancer) <- as.character(mbsub$id)
  trait(fad) <- cancer

  ## Identify the affected founders.
  ## First all affected individuals.
  affIds <- affectedIndividuals(fad)
  ## Identify founders for each family.
  founders <- lapply(unique(fad$family), function(z){
      return(findFounders(fad, family = z))
  })
  names(founders) <- unique(fad$family)

  ## Track the affected founder.
  affFounders <- lapply(founders, function(z){
      return(z[z %in% affIds])
  })
  ## Interestingly, not all founders are affected! It seems in some cases
  ## parents of the affected participants in the screening phase have also
  ## been included.
  affFounders <- affFounders[unlist(lapply(affFounders, length)) > 0]

  ## The number of families analyzed.
  length(founders)

  ## The number of families with affected founder.
  length(affFounders)

#+END_SRC

Unexpectedly, only in few families one of the founders is affected. For the
other families additional (unaffected) ancestors might have been added at a
later time point.

Next we get the number of affected individuals that are related to these
affected founders.

#+NAME: affected-for-founders
#+BEGIN_SRC R :ravel message = FALSE
  kin2affFounders <- shareKinship(fad, unlist(affFounders))

  ## How many of these are affected?
  sum(kin2affFounders %in% affIds)

  ## How many affected are not related to an affected founder?
  sum(!(affIds %in% kin2affFounders))

#+END_SRC

** Pedigree analysis methods

In this section we perform some more advanced pedigree operations. First, we
identify all individuals in the pedigree that share kinship with individual =4=.

#+NAME: shareKinship
#+BEGIN_SRC R :ravel message = FALSE
  ## Get all individuals sharing kinship with individual 4.
  shareKinship(fad, id = "4")
#+END_SRC

Next, we determine generations within the pedigree. Generations can only be
estimated for a single family, since in most instances e.g. the year of birth is
not available. Thus, generations are estimated considering the relation between
individuals, starting from the founder couple, i.e. generation 0, assigning
generation 1 to their children and all the mates of their children and so
on. The =estimateGenerations= method calculates such generation numbers for each
family defined in the object (or for a single family, if the family ID is
provided). The result is returned as a list with the list names corresponding to
the family ID and the list elements being the estimated generation numbers (with
names corresponding to the ID of the respective individual).

#+NAME: estimageGenerations
#+BEGIN_SRC R :ravel message = FALSE
  ## Estimate generation levels for all families.
  estimateGenerations(fad)[1:3]
#+END_SRC

Individuals without generation level (i.e. with an =NA=) are not connected to
any other individual in the pedigree (and thus most likely represent errors in
the pedigree).

In addition, it is also possible to calculate generation levels relative to a
(single) specified individual:

#+NAME: generationsFrom
#+BEGIN_SRC R :ravel message = FALSE
  gens <- generationsFrom(fad, id = "4")
#+END_SRC

We can render these generation numbers into the pedigree:

#+NAME: plotPed-with-generations
#+BEGIN_SRC R :ravel message=FALSE, fig.align='center', warning = FALSE
  plotPed(fad, family = 4, label2 = gens)
#+END_SRC

** Additional plotting options

If a trait information is available it might be of interest to highlight
affected individuals in the pedigree. Trait information should always be coded
as =0= (or =FALSE=) for unaffected and =1= (or =TRUE=) for affected. In the
example below, we use the /cancer/ information from the Minnesota Breast Cancer
Study.

#+NAME: set-trait
#+BEGIN_SRC R :ravel results='hide', message=FALSE
  ## Extract the cancer trait information.
  tcancer <- mbsub$cancer
  names(tcancer) <- mbsub$id
  ## Set the trait.
  trait(fad) <- tcancer

#+END_SRC

We can now extract the trait information from the object or identify directly
the phenotyped or affected individuals.

#+NAME: affectedIndividuals
#+BEGIN_SRC R :ravel message = FALSE
  ## Extract the trait information.
  head(trait(fad))

  ## We can also extract the IDs of the affected individuals.
  head(affectedIndividuals(fad))

  ## Or the IDs of the phenotyped individuals.
  head(phenotypedIndividuals(fad))
#+END_SRC

Plotting a =FAData= object with trait information results in a pedigree plot
with highlighted affected individuals (for =kinship2= pedigree plotting:
affected, unaffected and not phenotyped are represented as filled symbols, open
symbols and symbols with a question mark inside, respectively).

#+NAME: plotPed-with-trait
#+BEGIN_SRC R :ravel message=FALSE, fig.align='center', warning = FALSE
  ## Plotting the pedigree for family "9".
  plotPed(fad, family = "9")
#+END_SRC

In addition, we can manually highlight individuals using the =highlight.ids=
argument. For =kinship2= pedigree plotting, a list of length 2 is supported as
argument =highlight.ids=, with the first element being plotted on the top left
corner of the symbol and the second element on the top right corner.

#+NAME: plotPed-trait-highlight
#+BEGIN_SRC R :ravel message=FALSE, fig.align='center', warning = FALSE
  ## Plotting the pedigree for family "9".
  plotPed(fad, family = "9", highlight.ids = list(a = c("185", "201", "198"),
						  b = c("193")))
#+END_SRC

An alternative way to highlight individuals or add text to the plot is to use
the arguments =label1=, =label2= and =label3= or the =plotPed= method.

** Graph utilities

Pedigrees can also be transformed to graphs using the =ped2graph= function. That
way all graph theory methods implemented in e.g. the =igraph= package can be
applied to pedigrees.

#+NAME: ped2graph
#+BEGIN_SRC R :ravel message = FALSE
  ## Transform the full pedigree to a graph.
  fullGraph <- ped2graph(pedigree(fad))

  ## In addition, build the graph for a single family.
  singleFam <- ped2graph(family(fad, family=4))
#+END_SRC

We can plot these pedigrees also as graph and could use any of the layout
methods provided in the =igraph= package.

#+NAME: plot-igraph
#+BEGIN_SRC R :ravel fig.align='center', message = FALSE, fig.cap = "Pedigrees represented as graphs."
  ## Build the layout.
  plot(fullGraph)
  lay <- layout_(singleFam, on_grid())
  plot(singleFam, layout = lay)
#+END_SRC

The =connectedSubgraph= function implemented in the =FamAgg= package provides
additional functionality to find the smallest connected subgraph of a list of
submitted nodes (i.e. individuals).

In the code below we want to extract the smallest possible connected subgraph of
the pedigree-graph of family 4 containing individuals =7=, =8=, =27= and =17=.

#+NAME: connectedSubgraph
#+BEGIN_SRC R :ravel message = FALSE
  subgr <- connectedSubgraph(singleFam, nodes = c("7", "8", "27", "17"))
#+END_SRC

This is in principle what the =buildPed= method with the option =prune=TRUE=
does to find the smallest pedigree for a set of individuals, only that
=buildPed= ensures that also eventually missing parents are added.

#+NAME: plot-subgraph
#+BEGIN_SRC R :ravel subgraph-plot, fig.align='center'
  ## Plot the graph.
  plot(subgr)
  ## Similar to buildPed/plotPed with prune=TRUE.
  plotPed(fad, id=c("7", "8", "17", "27"), prune=TRUE)
#+END_SRC

* Importing and exporting pedigree data<<import.export>>

Besides providing the pedigree data as a =data.frame=, the =FAData= constructor
can also read pedigree data from various file formats, such as plink
\cite{Purcell:2007dg} /ped/ or /fam/ files
(http://pngu.mgh.harvard.edu/~purcell/plink/data.shtml) or generic text files.

#+NAME: import
#+BEGIN_SRC R :ravel message=FALSE
  ## Import a "ped" file.
  pedFile <- system.file("txt/minnbreastsub.ped.gz", package = "FamAgg")
  ## Quick glance at the file.
  readLines(pedFile, n = 1)
  fad <- FAData(pedFile)

  head(pedigree(fad))

#+END_SRC

Alternatively, we can import pedigree data from generic input files.

#+NAME: import-generic
#+BEGIN_SRC R :ravel message=FALSE
  ## Create the FAData by reading data from a txt file.
  pedFile <- system.file("txt/minnbreastsub.txt", package = "FamAgg")
  fad <- FAData(pedigree = pedFile, header = TRUE, id.col = "id",
		family.col = "famid", father.col = "fatherid",
		mother.col = "motherid")

#+END_SRC

And we can export pedigree data again using the =export= method. In the example
below, we subset the whole pedigree to the pedigree of family 4 and export this
as a /ped/ file.

#+NAME: export
#+BEGIN_SRC R
  tmpF <- tempfile()

  ## Subset the pedigree to family 4
  fam4 <- fad[fad$family == 4, ]

  ## Export data in ped format.
  export(fam4, tmpF, format = "ped")
#+END_SRC

* Testing for familial aggregation

Familial aggregation aims to identify families within large ancestral pedigrees
that show a non-random aggregation of traits.

As an example, we analyze here data from the Minnesota Breast Cancer Record,
which is provided by the =kinship2= package. In brief, this data set consists of
genealogical information from 426 unrelated founders diagnosed with breast
cancer whose families entered a longitudinal study on cancer in the state of
Minnesota (USA) in 1944. Cancer cases are encoded with a =1= in column =cancer=
in the =minnbreast= =data.frame=. Note however that, besides breast cancer, also
prostate cancer cases are reported. This unfortunately causes a systematic bias
in the data set as families were only included if a founder was diagnosed with
breast cancer, but all occurrences of both breast and prostate cancer are
reported. Based on this bias many of the results below should be taken with
caution. Another important information is provided in column =endage=, which
represents either the age of cancer onset, the age at the end of the study or
the age at death of the participant.

Note that, to reduce computation time, we perform the analysis only on a subset
of families from the Minnesota Breast Cancer record and reduce the number of
simulation runs. We specifically selected some families with a high percentage
of cancer cases, thus, the analysis presented here is biased. Also, in a real
analysis you should increase the =nsim= argument.


#+NAME: famagg-setup
#+BEGIN_SRC R :ravel warning=TRUE, message=FALSE
  library(FamAgg)
  set.seed(18011977)
  data(minnbreast)
  ## Subset the dataset to reduce processing time.
  mbsub <- minnbreast[minnbreast$famid %in% c(4:100, 173, 432), ]
  ## Uncomment the line below to use the whole dataset instead.
  ## mbsub <- minnbreast

  ## Define the number of simulations we perform.
  ## nsim <- 10000
  nsim <- 1000

  mbped <- mbsub[, c("famid", "id", "fatherid", "motherid", "sex")]
  ## Renaming column names.
  colnames(mbped) <- c("family", "id", "father", "mother", "sex")
  ## Create the FAData object.
  fad <- FAData(pedigree = mbped)

  ## Define the trait.
  tcancer <- mbsub$cancer
  names(tcancer) <- as.character(mbsub$id)
#+END_SRC

In the following section we analyze the data set first using the /genealogical
index/ method \cite{Hill:1980tz} (Section [[section.gi]]), then we estimate the
per-individual risk of disease using the /familial incidence rate/ (FIR, also
abbreviated as /FR/ in the original work) \cite{Kerber:1995cx} (Section
[[section.fr]]) and apply our /kinship sum test/ to identify affected individuals
exhibiting a higher relationship to other affected individuals than what would
be expected by chance (Section [[section.kinsum]]). Subsequently, we apply our
/kinship group test/ (Section [[section.kingroup]]) that allows to identify highly
clustered affected individuals within families.

In Section [[section.prob]] we apply the /probability test/ based on the method from
Yu et al \cite{Yu:2002vu} for inference on family disease clusters. We use the
corresponding implementation in the =gap= package. However, currently gap cannot
be directly applied to large pedigrees due to a specific limitation in the
implementation.

The /genealogical index of familiality/, the /familial incidence rate/ and the
/probability test/ are well established methods while the /kinship sum test/ and
the /kinship group test/ are novel approaches presented here for the first time.

** /Genealogical index of familiality/ <<section.gi>>

We next calculate the /genealogical index of familiality/ (GIF) \cite{Hill:1980tz}
(referred to as the /genealogical index/ in the original work) for cancer
occurrence in a subset of the Minnesota Breast Cancer Record data set. For a
given trait (e.g. whether or not an individual was diagnosed with a certain type
of cancer), the method computes the mean kinship between affected individuals
(cases) in the whole pedigree along with mean kinship values of randomly drawn
sets of individuals. The distribution of average kinship values among the
control sets is then used to estimate the probability that the observed level of
kinship among the cases is due to chance.

Below, we perform the analysis using the =genealogicalIndexTest= method on the
=cancer= trait. In its default setting, the =genealogicalIndexTest= function uses
all phenotyped individuals in the pedigree as control population from which sets
of random samples equal in size to the number of affected are drawn.

Note that by default the function excludes all singletons (i.e. unconnected
individuals in the pedigree) from the analysis. Changing the argument
=rm.singletons= to =FALSE= will estimate the GIF on the full data set.

#+NAME: gif
#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  ## Calculate the genealogical index of familiality.
  gi <- genealogicalIndexTest(fad, trait = tcancer,
			      traitName = "cancer", nsim = nsim)

  ## Display the result.
  result(gi)
#+END_SRC

The column /genealogical index/ of the result =data.frame= shown above represents
the mean kinship between all pairs of affected individuals in the pedigree
multiplied by =100000= for easier interpretation.  Thus, according to the GIF
test, a clustering of cancer cases is present in the analyzed pedigree. The
output messages from the method call indicate that some individuals have been
excluded from the test since they were either not phenotyped in the trait
(i.e. have a missing value in trait), or are not /connected/ in the family
pedigree (do not share kinship with any other individual in the pedigree after
removing non-phenotyped individuals).

The genealogical index of familiality implementation in this package adds some
more flexibility to the original approach. The definition of the appropriate set
of control individuals from which random samples are drawn can be specified with
the =controlSetMethod= argument. Also, it is possible to perform a stratified
sampling, e.g. if the group of affected cases in a pedigree consists of 5 female
and 3 male individuals, submitting the sex of each individual in the pedigree
with the argument =strata= (i.e. =strata=fad$sex=, with =fad= being the =FAData= object
on which the analysis is performed) allows the function to define random control
sets with the same proportion of male/female individuals.

In the next example, we use the =getSexMatched= function to define the set of
control individuals and also the =getExternalMatched= submitting the gender
information of each individual. The results from both approaches are essentially
identical, and in the present data set not that useful, as the Minnesota Breast
Cancer data set lists both, breast cancer and prostate cancer in column =cancer=,
thus, the set of control individuals will contain all individuals with known
sex.

#+NAME: gif-2
#+BEGIN_SRC R :ravel warning=FALSE, eval=FALSE
  ## Calculate the genealogical index of familiality using random sampling from
  ## a sex matched control set.
  giSexMatch <- genealogicalIndexTest(fad, trait = tcancer,
				      traitName = "cancer", nsim = nsim,
				      controlSetMethod = "getSexMatched")

  ## Use an external vector to perform the matching.
  ## The results are essentially identical.
  giExtMatch <- genealogicalIndexTest(fad, trait = tcancer,
				      traitName = "cancer", nsim = nsim,
				      controlSetMethod = "getExternalMatched",
				      match.using = fad$sex)
#+END_SRC

Note that any matching or stratified sampling can lead to the exclusion of
individuals with missing values in either the matching criteria or the strata.

In the Minnesota Breast Cancer data set, the number of prostate cancer cases is
much lower than the number of breast cancer cases, thus, simple random sampling
might result in an biased genealogical index of familiality estimate since about
the same proportion of male and female individuals will be sampled. To account
for such cases a stratified sampling, as performed below, can be used instead.

#+NAME: gif-3
#+BEGIN_SRC R :ravel message=FALSE
  ## Evaluate the proportion of male and femal cases.
  table(gi$sex[affectedIndividuals(gi)])

  ## We can use the gender information to perform stratified sampling, i.e.
  ## in each permutation a random set of 3 male and 15 females will be selected.
  giStrata <- genealogicalIndexTest(fad, trait = tcancer,
				    traitName = "cancer", nsim = nsim,
				    strata = fad$sex)

  result(giStrata)
#+END_SRC

Finally, we plot the result from the simulation. The blue vertical line in the
plot below represents the mean kinship value between all affected individuals in
the pedigree. The distribution of mean kinship values from the 1000 randomly
drawn sets are shown in grey color.

#+NAME: gif-4-plot
#+BEGIN_SRC R :ravel mbreast-genealogical-index-result, message=FALSE, warning=FALSE, fig.align='center'
  ## Plot the result.
  plotRes(giStrata)
#+END_SRC

The genealogical index of familiality can also be estimated by the =gif=
function from the =gap= R-package. Below we calculate the estimate using both
methods and compare the resulting estimate. Note that the =gif= method reports
only the genealogical index of familiality estimate but does not estimate
significance.

#+NAME: gif-gap
#+BEGIN_SRC R :ravel message=FALSE
  library(gap)

  ## Adding the trait information, so the extracted pedigree data.frame will
  ## also contain a column "affected" with that information.
  trait(fad) <- tcancer

  ## Extract the pedigree and re-format it for the gif function.
  pedi <- pedigree(fad)
  ## Remove singletons.
  pedi <- removeSingletons(pedi)
  pedi[is.na(pedi$father), "father"] <- 0
  pedi[is.na(pedi$mother), "mother"] <- 0

  ## Identify the affected individuals.
  affIds <- as.numeric(pedi$id[which(pedi$affected == 1)])

  ## Execute the gif method contained in the gap package.
  gifRes <- gif(pedi[, c("id", "father", "mother")], affIds)

  ## Calculate the GIF using FamAgg's genealogicalIndexTest.
  gifT <- genealogicalIndexTest(fad, trait = tcancer, nsim = 100)

  ## Comparing the results:
  gifRes[[1]] == result(gifT)$genealogical_index
#+END_SRC

Thus, the GIF estimate from the =gap= package is identical to the one from the
=FamAgg= package.

In the examples above, we tested for an enrichment of cancer cases in the full
data set, i.e. across all families. In addition, we can perform the test
individually for each family, by setting the =perFamilyTest= parameter of the
=genealogicalIndexTest= to =TRUE=, and thus test for a clustering of cancer
cases within each family.

#+NAME: gif-5
#+BEGIN_SRC R :ravel message=FALSE, warning=FALSE
  ## Perform the analysis (no strata etc) separately for each family.
  giFam <- genealogicalIndexTest(fad, trait = tcancer, nsim = nsim,
				 perFamilyTest = TRUE,
				 traitName = "Cancer")

  ## Display the result from the analysis.
  head(result(giFam))
#+END_SRC

** /Familial incidence rate/ (FIR)<<section.fr>>

# The FR from Kerber
A per-individual risk of e.g. disease can be calculated using the /familial
incidence rate/ (FIR, abbreviated as /FR/ in the original work)
\cite{Kerber:1995cx}. This measure considers the kinship of each individual with
any affected in a given trait in the pedigree and the time at risk for each
individual. Thus, the FIR is an estimate for the risk per gene-time for each
individual given the disease-experience in the cohort.

As /time at risk/ for each individual we use the =endage= column in the
Minnesota Breast Cancer data set, which represents the participant's age at the
last follow-up or at cancer incidence. This estimate of time at risk is rather
crude and in a real life situation a better, more accurate, estimate that is
based e.g. on the birth dates and dates of last follow up or incidence might be
used instead. See the help of functions =estimateTimeAtRisk= and =sliceAge= for
details and options related to /time at risk/.

#+NAME: fir-1
#+BEGIN_SRC R :ravel warning=FALSE, message = FALSE
  ## Estimate the risk for each individual using the familial incidence
  ## rate method. We use the "endage" provided in the Minnesota Breast Cancer
  ## Record as a measure for time at risk.
  fr <- familialIncidenceRate(fad, trait = tcancer, timeAtRisk = mbsub$endage)

#+END_SRC

A note on singletons: for all per-individual measures unconnected individuals
within the pedigree are automatically excluded from the calculations as no
kinship-based statistics can be estimated for them (they do, by definition, not
share kinship with any other individual in the pedigree, thus their kinship
coefficient with any other individual in the pedigree will be =0=). Note also
that the removal of e.g. not phenotyped individuals prior to the calculation can
also /generate/ singletons, that additionally become removed. This removal
results in an estimate with the value =NA= for all singletons as well as not
phenotyped individuals.

Next, we calculate the mean FIR within each family and plot this information.

#+NAME: fir-2
#+BEGIN_SRC R :ravel mbreast-mean-fr-per-family, message=FALSE, warning=FALSE, fig.align='center'
  ## Split the FIR by family and average the values within each.
  frFam <- split(fr, f = fad$family)
  frFamAvg <- lapply(frFam, mean, na.rm = TRUE)

  ## Sort and plot the averages.
  frFamAvg <- sort(unlist(frFamAvg), decreasing = TRUE)
  plot(frFamAvg, type = "h", xaxt = "n", xlab = "", ylab = "mean FIR",
       main = "Per family averaged familial incidence rate")
  axis(side = 1, las = 2, at = 1:length(frFamAvg), label = names(frFamAvg))

#+END_SRC

Not unexpectedly, individuals in some families have on average a higher familial
incidence rate, and thus a higher risk of cancer than others.

In the next example, we calculate the familial incidence rate assessing in
addition the significance of each estimate using Monte Carlo simulations. This
extension to the original approach from Kerber \cite{Kerber:1995cx} does also
allow stratified sampling.

#+NAME: fir-3
#+BEGIN_SRC R :ravel warning=FALSE, message=FALSE
  ## Estimate the risk for each individual using the familial incidence
  ## rate method. We use the endage provided in the Minnesota Breast Cancer
  ## Record as a measure for time at risk.
  frTest <- familialIncidenceRateTest(fad, trait = tcancer,
				      traitName = "cancer",
				      timeAtRisk = mbsub$endage,
				      nsim = nsim)

#+END_SRC

The familial incidence rate can be extracted easily from the result object using
the =familialIncidenceRate= method or using =$fir=. Also, the empirical p-value
from the simulation analysis and the time at risk can be accessed using the =$=
operator (i.e. using =$pvalue=, =$tar= or =$timeAtRisk=, respectively).

#+NAME: fir-4
#+BEGIN_SRC R
  head(familialIncidenceRate(frTest))
  head(frTest$fir)

#+END_SRC

Finally, we inspect the results from the analysis.

#+NAME: fir-5
#+BEGIN_SRC R
  head(result(frTest))

#+END_SRC

We can also identify the families containing individuals with a significant FIR.

#+NAME: fir-6
#+BEGIN_SRC R
  frRes <- result(frTest)
  frSig <- frRes[which(frRes$padj < 0.05), ]

  ## Split by family.
  frFam <- split(frSig, frSig$family)
  frRes <- data.frame(family = names(frFam),
		      no_sign_fir = unlist(lapply(frFam, nrow)))
  ## Determine the number of phenotyped and affected individuals per family.
  noPheNAff <- sapply(names(frFam), function(z){
      fam <- family(frTest, family = z)
      return(c(no_pheno = sum(!is.na(fam$affected)),
	       no_aff = length(which(fam$affected == 1))
	       ))
  })
  frRes <- cbind(frRes, t(noPheNAff))

  ## Display the number of phenotyped and affected individuals as well as
  ## the number of individuals within the families with a significant FIR.
  frRes[order(frRes[, "no_sign_fir"], decreasing = TRUE), ]
#+END_SRC

We have an enrichment of affected cases in families 173, 13 and 432.

** /Kinship sum test/ <<section.kinsum>>

# The kinship sum test; compare significant individuals to high FIR.
Next, we use the /kinship sum test/ that evaluates familial aggregation based on
the sum of kinship values between affected cases. The test identifies affected
individuals exhibiting a higher relationship to other affected individuals than
would be expected by chance. By specifying the =strata= we perform
sex-stratified random sampling, i.e. ensure that the proportion of male and
female individuals in each randomly sampled group matches the corresponding
proportions in the /real/, observed, affected.

#+NAME: kinsum-1
#+BEGIN_SRC R :ravel message = FALSE
  ## Perform the kinship sum test.
  kinSum <- kinshipSumTest(fad, trait = tcancer, traitName = "cancer",
			   nsim = nsim, strata = fad$sex)
  head(result(kinSum))

#+END_SRC

Next, we identify those individuals that have a significant kinship sum
accepting a 10% false discovery rate (FDR).

#+NAME: kinsum-2
#+BEGIN_SRC R :ravel message = FALSE
  ## Extract the IDs of the individuals with significant kinship. By default,
  ## the raw p-values are adjusted for multiple hypothesis testing using the
  ## method from Benjamini and Hochberg.
  kinSumRes <- result(kinSum)
  kinSumIds <- as.character(kinSumRes[kinSumRes$padj < 0.1, "affected_id"])

  ## From which families are these?
  table(kinSumRes[kinSumIds, "family"])
#+END_SRC

Thus, most of the identified significant individuals are from two families.
Next, we compare the FIR scores of affected or unaffected (but phenotyped)
individuals in this family to the FIR scores of affected or unaffected
individuals of all other families.

#+NAME: kinsum-3
#+BEGIN_SRC R :ravel mbreast-family-432-FIR-compared-to-others, message=FALSE, warning=FALSE, fig.align='center'
  ## Get the familial ratio of the significant in this family, of all in
  ## this family, and of all others.
  famId <- kinSumRes[1, "family"]

  ## Extract the family.
  fam <- family(kinSum, family = famId)

  ## Stratify individuals in affected/unaffected.
  strat <- rep("All, unaff.", length(kinSum$id))
  strat[which(kinSum$affected > 0)] <- "All, aff."
  strat[kinSum$id %in% fam$id] <- paste0("Fam ", famId, ", unaff.")
  strat[kinSum$id %in% fam$id[which(fam$affected > 0)]] <-
      paste0("Fam ",famId,", aff.")

  famData <- data.frame(fr = fr, group = strat)
  boxplot(fr~group, data = famData, na.rm = TRUE, ylab = "FIR",
	  col = rep(c("#FBB4AE", "#B3CDE3"), 2))

#+END_SRC

As expected, the familial incidence rate (i.e., in the present data set, the
risk of individuals to get cancer, given their kinship to other cancer cases)
for individuals (whether affected or yet unaffected) in this family is higher
than in the data set analyzed here.

Next, we plot the pedigree of this family.

#+NAME: kinsum-4
#+BEGIN_SRC R :ravel mbreast-family-432-affected, message=FALSE, warning=FALSE, fig.align='center'
  ## Plot the pedigree for the family of the selected individual removing
  ## all individuals that were not phenotypes.
  plotPed(kinSum, id = kinSumIds[1], cex = 0.3, only.phenotyped = TRUE)


#+END_SRC

And finally, also plot the kinship sum for the individuals with the largest
kinship sum in relation to the /expected/ kinship sums from the Monte Carlo
simulations.

#+NAME: kinsum-5
#+BEGIN_SRC R :ravel mbreast-family-432-affecte-res, message=FALSE, warning=FALSE, fig.align='center'
  plotRes(kinSum, id = kinSumIds[1])
#+END_SRC

** /Kinship group test/ <<section.kingroup>>

# The kinship group test (Daniel).
Here we apply the /kinship group test/ to the data set. This test first defines
for each affected individual a group of individuals considering only individuals
that are as closely related as the most distant affected individual.  For each
of these kinship groups two tests are then performed, one by comparing the mean
kinship among affected in the group with the mean kinship from Monte Carlo
simulations (ratio test) and one evaluating the largest observed kinship value
between affected individuals with those of random samples from the simulation
(kinship group test).

In the example below we specify again the =strata= argument and thus perform
sex-stratified random sampling.

#+NAME: kingroup-1
#+BEGIN_SRC R :ravel message=FALSE
  ## Calculate the kinship test.
  kinGroup <- kinshipGroupTest(fad, trait = tcancer,
			       traitName = "cancer",
			       nsim = nsim, strata = fad$sex)
  head(result(kinGroup))

#+END_SRC

The kinship group test finds a significant aggregation of cases in families 13,
72, 173 and 432. In fact, as we see further below, the test identified a
subgroup in the latter which shows with an exceptional high proportion of cases.

Below, we summarize the results further by listing the total number of families
in the pedigree and the number of families in which kinship groups with
significant kinship p-value and significant ratio p-value (both at a 5% FDR).

#+NAME: kingroup-2
#+BEGIN_SRC R :ravel message = FALSE
  kinGroupRes <- result(kinGroup)
  ## Create a data.frame with the summarized results.
  resTab <- data.frame(total_families = length(unique(kinGroup$family)),
		       ratio_sign = length(unique(
			   kinGroupRes[kinGroupRes$ratio_padj < 0.05, "family"]
		       )),
		       kinship_sign = length(unique(
			   kinGroupRes[kinGroupRes$kinship_padj < 0.05, "family"]
		       ))
		       )
  resTab
#+END_SRC

The most significant kinship group identified by the kinship group test is shown
in the figure below. The mother (individual =17609=) of the nuclear family
representing this group and all her daughters have cancer (see figure
below). This mother is however not directly related to the affected founder of
this family, individual =17517=, but did marry her son (id =17530=; see figure above
for the full pedigree of this family =432=).

We are also submitting the familial incidence rate values calculated above with
argument =label1= which are then displayed below the ID of each individual in the
plot.

#+NAME: kingroup-3
#+BEGIN_SRC R :ravel mbreast-family-432-affecte-res-kinship, message=FALSE, warning=FALSE, fig.align='center'
  plotPed(kinGroup, id = kinGroupRes[kinGroupRes$family == "432",
				     "group_id"][1],
	  prune = TRUE, label1 = fr)
#+END_SRC

** Exact inference for family disease clusters (/probability test/)<<section.prob>>

In this section, we apply the /probability test/ that is based on the method from
Yu et al \cite{Yu:2002vu} for inference on family disease clusters. We use the
corresponding implementation in the =gap= package, that, due to an implementation
specific limitation, can however not be directly applied to large pedigrees as
the present, but requires definitions of smaller pedigree sub-sets (cliques).

We will thus restrict the analysis to families with fewer than 22 individuals
and provide this information with the argument =cliques=. Unfortunately, this
excludes most families in the present pedigree that exhibit significant familial
aggregation of cancer.

#+NAME: probtest-1
#+BEGIN_SRC R :ravel message=FALSE
  ## First we load the trait/affected information into the FAData object.
  trait(fad) <- tcancer

  ## Next we determine the number of phenotyped individuals per family.
  famAff <- pedigree(fad)[, c("family", "affected")]
  ## Exclude individuals that were not phenotyped.
  famAff <- famAff[!is.na(famAff$affected), ]
  ## Calculate the number of phenotyped per family.
  famSize <- table(famAff$family)

  keepFams <- names(famSize)[famSize < 22]

  ## Extract the family and restrict to those on which we can perform
  ## the analysis.
  famCliq <- fad$family
  famCliq <- famCliq[famCliq %in% keepFams]

#+END_SRC

Now we can run the analysis.

#+NAME: probtest-2
#+BEGIN_SRC R :ravel message=FALSE
  probRes <- probabilityTest(fad, trait = tcancer,
			     traitName = "Cancer",
			     cliques = famCliq, nsim = nsim)
  probResTab <- result(probRes)
  head(probResTab)
#+END_SRC

We plot the pedigree for the most significant clique. Notice however, that there
are no significant results, as it can be seen from the =pvalue= and =padj= columns
in the result table above.

#+NAME: probtest-3
#+BEGIN_SRC R :ravel mbreast-prob-clique-1, message=FALSE, warning=FALSE, fig.align='center'
  plotPed(probRes, id = probResTab[1, "group_id"])
#+END_SRC

** Binomial test

The binomial test evaluates whether the number of affected in a family (or the
whole pedigree) is significantly higher than what would be expected by chance
(given a probability of being affected in a trait). In contrast to most other
methods this test does not take the degree of kinship between individuals into
account and is hence independent of the family structure in the pedigree. We can
perform this type of test using the =binomialTest= function on any =FAData= object
or any object extending it. Below we use the binomial test to evaluate a
significant enrichment of affected individuals in any family in the pedigree.

#+NAME: bintest-1
#+BEGIN_SRC R :ravel message = FALSE
  binRes <- binomialTest(fad, trait = tcancer, traitName = "Cancer")

  binResTab <- result(binRes)
  head(binResTab)
#+END_SRC

The probability used on the binomial test is shown in column ="prob"= and is in
essence the ratio between the affected and phenotyped in the pedigree
(i.e. 154/2202). This might be an overestimation, especially if the provided
pedigree is not representative of the population. A population-based probability
can however be provided with argument =prob=. Below we test specifically whether
we have families in which the number of individuals with breast cancer is
significantly higher than expected. To this end we set the trait status of all
male individuals to =NA= and repeat the test providing the probability of
developing breast cancer during in women, which, according to the U.S. Breast
Cancer Statistics (from breastcancer.org) is 1 out of 8 in their life time.

#+NAME: bintest-2
#+BEGIN_SRC R :ravel message = FALSE
  ## Set the trait status to NA for all male individuals.
  tcancer[fad$sex == "M" | is.na(fad$sex)] <- NA

  ## Perform the test providing also the population probability
  binRes <- binomialTest(fad, trait = tcancer, prob = 1/8)

  binResTab <- result(binRes)
  head(binResTab)
#+END_SRC

Below we plot the pedigree for the family with the strongest enrichment with
affected individuals.

#+NAME: bintest-3
#+BEGIN_SRC R :ravel message = FALSE, fig.align = "center", fig.pos = "h!"
  plotPed(binRes, family = 173)
#+END_SRC

** Familial standardized incidence rate 			   :noexport:

The familial standardized incidence rate (FSIR) \cite{Kerber:1995cx} weights the
disease status of relatives based on their degree of relatedness with the
proband. Formally, the FSIR is defined as the standardized incidence rate (SIR)
or standardized mortality rate \cite{Breslow:1987wc} in epidemiology, i.e. as
the ratio between /observed/ and /expected/ number of cases, only that both are
in addition also weighted by the degree of relatedness (i.e. kinship value)
between individuals in the pedigree.

In the next example we calculate the familial incidence rate assessing in
addition the significance of the calculated rate for each individual using Monte
Carlo simulations. As /time at risk/ we use, as above, column =endage= from the
Minnesota Breast Cancer data set, that, if provided, represents the age of
cancer onset, the age of death or age at end of study. In addition we perform
stratified sampling.

#+BEGIN_SRC R :ravel warning=FALSE
  ## Calculating the familial incidence rate using the "endage" as time at risk
  ## and performing sex-stratified sampling.
  fir <- familialIncidenceRateTest(fad, trait=tcancer, nsim=nsim,
                                   timeAtRisk=mbsub$endage, strata=fad$sex)
  head(result(fir))
  ## The number of individuals with a (raw) p-value < 0.05
  length(which(result(fir)$pvalue < 0.05))

  ## use the $fir accessor.

#+END_SRC


Next we calculate the familial standardized incidence rate, using population
incidence rates for breast and prostate cancer from Cancer Research UK. The
numbers are given as number of new cases per 100000 individuals per year, 155.3
and 1.1 for breast cancer in females and males and 0 and 134.3 for prostate
cancer in females and males. We are thus summing the cases for breast and
prostate cancer for males and females, divide that by 100000 and use this as
argument /lambda/.

As described above, only families of a founder diagnosed with breast cancer were
included in the study, while both, breast and prostate cancer cases were
considered within each family. Thus, the results from the FSIR might be biased.

#+BEGIN_SRC R :ravel warning=FALSE

#+END_SRC

+ Compare FIR vs FSIR.


* TODOs								   :noexport:

** CANCELED Find a way to calculate the pedigree size.
   CLOSED: [2015-08-24 Mon 08:18]
   - State "CANCELED"   from "TODO"       [2015-08-24 Mon 08:18] \\
     Don't think I need that at all...
+ [ ] include in =result= for =FAProbResult=.
+ [ ] include in =result= for =FAKinshipResult=.
** DONE Include the php script. [2/2]
   CLOSED: [2015-07-23 Thu 10:43]
   - State "DONE"       from "TODO"       [2015-07-23 Thu 10:43]
+ [X] Locate the script and include it into the package.
+ [X] Check what we can use from that script and whether it might not be better
  to re-implement it!

** CANCELED Include the plotting script. [1/1]
   CLOSED: [2015-09-16 Wed 11:01]
   - State "CANCELED"   from "TODO"       [2015-09-16 Wed 11:01] \\
     In the meantime we excluded it again...
+ [X] Locate the script and include it into the package.

** DONE Generate unit tests: [5/5]
   CLOSED: [2015-09-16 Wed 11:00]
   - State "DONE"       from "TODO"       [2015-09-16 Wed 11:00]
+ [X] FAData.
+ [X] FAResult.
+ [X] FAKinClustResult.
+ [X] FAKinshipResult.
+ [X] FAProbResult.

** DONE Remove the CHRIS data and the =test_validate_new.R= test script.
   CLOSED: [2015-09-18 Fri 13:47]
   - State "DONE"       from "TODO"       [2015-09-18 Fri 13:47]
** CANCELED Implement a method =plotPedForId= for =FAResult=.
   CLOSED: [2015-07-27 Mon 10:43]
   - State "CANCELED"   from "TODO"       [2015-07-27 Mon 10:43] \\
     implemented plotPed instead.
+ add a 1 to =is.proband= for the current id.
+ add the age (if available) at the bottim (=text.below.symbol=).
+ add an r to =text.in.symbol= for those that are related to the current
  individual (i.e. have kinship larger 0) with the proband and were phenotyped.

** CANCELED Implement a method =plotPedForFam= for =FAResult=.
   CLOSED: [2015-07-27 Mon 10:44]
   - State "CANCELED"   from "TODO"       [2015-07-27 Mon 10:44] \\
     Implemented plotPed instead.
** DONE =plotPed= for =FAData=
   CLOSED: [2015-07-23 Thu 10:45]
   - State "DONE"       from "TODO"       [2015-07-23 Thu 10:45]
   - plots for id or full family.
** DONE =plotPed= for =FAResult=
   CLOSED: [2015-07-23 Thu 10:45]
   - State "DONE"       from "TODO"       [2015-07-23 Thu 10:45]
   - calls the =FAData= method.
** DONE =plotPed= for =FAKinClustResult=
   CLOSED: [2015-07-23 Thu 10:45]
   - State "DONE"       from "TODO"       [2015-07-23 Thu 10:45]
   - Plots are the same as in the original php version.
** DONE =plotPed= for =FAKinshipResult=
   CLOSED: [2015-08-17 Mon 11:47]
   - State "DONE"       from "TODO"       [2015-08-17 Mon 11:47]
- A little tricky, since we can't make it working as the php version (does that
  make sense anyway?).
- plots the full pedigree for an id and highlights those included in the test.

** DONE =plotPed= for =FAProbabilityResult=
   CLOSED: [2015-08-17 Mon 11:47]
   - State "DONE"       from "TODO"       [2015-08-17 Mon 11:47]
** DONE Implement a =prune= option for =plotPed= on =FAKinshipResult= and =FAProbResult= [2/2]
   CLOSED: [2015-08-17 Mon 11:47]
   - State "DONE"       from "TODO"       [2015-08-17 Mon 11:47]
+ [X] =FAKinshipResult=.
+ [X] =FAProbResult=.

** DONE Documentation [6/6]:
   CLOSED: [2015-08-17 Mon 11:47]
   - State "DONE"       from "TODO"       [2015-08-17 Mon 11:47]
+ [X] =FAData=.
+ [X] =FAResult=.
+ [X] =FAKinClustResult=.
+ [X] =FAKinshipResult=.
+ [X] =FAProbResult=.
+ [X] Pedigree Utility functions (=ped2graph= etc.).
  - =subPedigree=.
  - =ped2graph=.

** DONE Implement the plotting function based on =kinship2= to show the same info as HaploPainter.
   CLOSED: [2015-08-24 Mon 08:18]
   - State "DONE"       from "TODO"       [2015-08-24 Mon 08:18]
+ [X] First argument is proband.
+ [X] Second affected.


** DONE Clean the test cases from any code referring to CHRIS data
   CLOSED: [2015-09-16 Wed 11:01]
   - State "DONE"       from "TODO"       [2015-09-16 Wed 11:01]
+ Move the evaluation code (comparison with original code) to some =notrun_=
  functions in a separate test file.

** DONE Implement a =[= method to subset.
   CLOSED: [2015-08-21 Fri 14:08]
   - State "DONE"       from "TODO"       [2015-08-21 Fri 14:08]
** DONE Re-evaluate: what with affected status =NA=
   CLOSED: [2015-08-24 Mon 08:18]
   - State "DONE"       from "TODO"       [2015-08-24 Mon 08:18]
- =ks2paint=: affected being NA are replaced by 0! FIXED!
- haplopaint?


** DONE Implement the Hill method significant over-representation of a disease in a family
   CLOSED: [2015-09-16 Wed 11:01]
   - State "DONE"       from "TODO"       [2015-09-16 Wed 11:01]
+ Method from Jon Rice Hill \cite{Hill:1980tz}.
+ Approach (chapter 4): compare the mean kinship of affected in a pedigree (same family!) to
  the distribution of mean kinships of random control groups.
  - Works only within a family.
  - Calculate mean kinship of the affected.
  - Randomly select x times the same number of cases from the control
    population, calculate mean for each and generate that way the background
    distribution.

+ Implement:
  - [X] Method: =matchedControlGroup=, takes IDs as input and returns a vector
    of IDs of suitable controls, matching them by generation,
  - [X] Method: =sampleMatchedControls=: randomly samples IDs from the matched
    controls, considering also the probability for sex.

** CANCELED Implement the Kerber method.
   CLOSED: [2015-11-13 Fri 07:31]
   - State "CANCELED"   from "TODO"       [2015-11-13 Fri 07:31] \\
     No idea what I meant with that. Actually, I implemented both methods from Kerber
     in the end, the FIR and the FSIR.
** DONE Implement =plotRes= method for =FAKinClustResult=.
   CLOSED: [2015-09-18 Fri 13:45]
   - State "DONE"       from "TODO"       [2015-09-18 Fri 13:45]
** DONE Implement =plotRes= method for =FAKinshipResult=.
   CLOSED: [2015-09-18 Fri 13:45]
   - State "DONE"       from "TODO"       [2015-09-18 Fri 13:45]
** CANCELED Implement =plotRes= method for =FAProbResult=.
   CLOSED: [2015-09-18 Fri 13:46]
   - State "CANCELED"   from "TODO"       [2015-09-18 Fri 13:46] \\
     No way to do that...
** DONE Implement strata sampling for =FAKinClustResult=.
   CLOSED: [2015-09-21 Mon 13:40]
   - State "DONE"       from "TODO"       [2015-09-21 Mon 13:40]
** DONE Check/update the help page for =FAProbResult=
   CLOSED: [2015-09-21 Mon 13:41]
   - State "DONE"       from "TODO"       [2015-09-21 Mon 13:41]
** DONE Implement strata sampling for =FAKinGroupResults=
   CLOSED: [2015-10-09 Fri 06:58]
   - State "DONE"       from "TODO"       [2015-10-09 Fri 06:58]
** DONE Remove the obsolete =FAResult= object.
   CLOSED: [2015-09-22 Tue 15:20]
   - State "DONE"       from "TODO"       [2015-09-22 Tue 15:20]

** DONE Rename =FAKinshipResult= into =FAKinGroup=
   CLOSED: [2015-09-23 Wed 07:20]
   - State "DONE"       from "TODO"       [2015-09-23 Wed 07:20]
** DONE Rename =FAKinClustResult= into =FAKinSum=
   CLOSED: [2015-09-23 Wed 07:20]
   - State "DONE"       from "TODO"       [2015-09-23 Wed 07:20]

** DONE Implement a =familialIncidenceRateTest= with simulation. [100%]
   CLOSED: [2016-01-07 Thu 15:39]
   - State "DONE"       from "TODO"       [2016-01-07 Thu 15:39]
+ [X] =FAFamRateResults= class similar to the above ones. What would be the
  /ideal/ name? =FAIncidenceRateResults=, =FARateResults=, =FAInciRateResults=,
  =FAFirResults=? *Name*: =FAIncidenceRateResults=
+ [X] Implement random sampling to generate a background distribution and
  assess significance levels for familial incidence rates.
+ [X] Implement the =result= method.
+ [X] Implement the =plotRes= method.
+ [X] Implement the =plotPed= method.
+ [X] Documentation.
+ [X] Vignette.

** TODO Implement a =fsirTest= with simulation. [92%]

+ [X] Class: =FAStdIncidenceRateResults=.
+ [X] Implement random (stratified) sampling method.
+ [X] Implement the =result= method.
+ [X] Implement the =[= and the =show= method.
+ [X] Implement the =plotPed= method.
+ [X] Implement the =plotRes= method.
+ [X] Implement the =timeInStrata= getter/setter method.
+ [X] Implement the =lambda= getter method.
+ [X] Implement the =fsir= method for =FAStdIncidenceRateResults= object (just
  returning =@sim$fsir=).
+ [X] Implement the =$= method for =FAStdIncidenceRateResults= object.
+ [X] Method =resultForId= for a single individual that lists: fsir, timeAtRisk,
  lambda and eventually p-value.
+ [X] Documentation.
+ [ ] Vignette.

** CANCELED Check and eventually implement some more =$= methods for the results objects. [/]
   CLOSED: [2016-01-07 Thu 15:31]
   - State "CANCELED"   from "TODO"       [2016-01-07 Thu 15:31] \\
     With the exception of the FIR and the FSIR such accessors do now make much
     sense, the GIF is a measure for the full pedigree, the kinship sum is only
     calculated for affected individuals and the kinship group test gives a measure
     for a affected group and not a single affected individual.
We've got already some nice =$= methods for =FAIncidenceRateResults= and
=FAStdIncidenceRateResults=, would be nice to have some similar ones for the
other methods (e.g. to directly access estimates or the p-value).
These make however more sense for per-individual tests, otherwise the use of the
=$= operator might be misleading, since e.g. =$id= returns the ids of all
individuals in the pedigree.


** DONE Merge the git and svn FamAgg version [40/40]
   CLOSED: [2015-12-02 Wed 08:47]
   - State "DONE"       from "TODO"       [2015-12-02 Wed 08:47]
Have to merge the two versions, since development in the svn FamAgg continued
independently of the git version (in which stuff related to the inclusion into
Bioconductor was changed).

+ [X] DESCRIPTION
+ [X] NAMESPACE

+ [X] R/Classes.R
+ [X] R/Constructors.R
+ [X] R/Generics.R
+ [X] R/Methods-FAData.R
+ [X] R/Methods-FAGenIndexResults.R
+ [X] R/Methods-FAIncidenceRatio.R <- Methods-FAIncidenceRateResults.R
+ [X] R/Methods-FAKinGroupResults.R
+ [X] R/Methods-FAKinSumResults.R
+ [X] R/Methods-FAProbResults.R
+ [X] <- R/Methods-FAStdIncidenceRateResults.R
+ [X] R/Methods.R
+ [X] R/matched-controls.R
+ [X] R/plotting-functions.R
+ [X] R/utils.R
+ [X] zzz.R

+ [X] inst/unitTests/test_FAData.R
+ [X] inst/unitTests/test_controls_N_sampling.R
+ [X] inst/unitTests/test_fsir.R
+ [X] inst/unitTests/test_genealogical_index.R
+ [X] inst/unitTests/test_incidence_ratio.R
+ [X] inst/unitTests/test_kinship_group.R
+ [X] inst/unitTests/test_kinship_sum.R
+ [X] inst/unitTests/test_plotting.R
+ [X] inst/unitTests/test_probability.R
+ [X] inst/unitTests/test_utilities.R

+ [X] inst/NEWS

+ [X] man/FAData-analysis.Rd
+ [X] man/FAData.Rd
+ [X] man/FAGenIndexResults.Rd
+ [X] <- man/FAIncidenceRateResults.Rd
+ [X] man/FAKinGroupResults.Rd
+ [X] man/FAKinSumResults.Rd
+ [X] man/FAProbResults.Rd
+ [X] <- man/FAStdIncidenceRateResults.Rd
+ [X] man/Pedigree-utils.Rd
+ [X] man/defineControls.Rd
+ [X] man/plotting-functions.Rd

+ [X] vignettes/FamAgg.org

** DONE Import/export /FAM/ format [/]
   CLOSED: [2015-12-15 Tue 14:43]
   - State "DONE"       from "TODO"       [2015-12-15 Tue 14:43]
FAM files are from plink. Description:
https://www.cog-genomics.org/plink2/formats.
Text file without header, space or tab separated.
Fields:
+ Family ID ('FID')
+ Within-family ID ('IID'; cannot be '0')
+ Within-family ID of father ('0' if father isn't in dataset)
+ Within-family ID of mother ('0' if mother isn't in dataset)
+ Sex code ('1' = male, '2' = female, '0' = unknown)
+ Phenotype value ('1' = control, '2' = case, '-9'/'0'/non-numeric = missing
  data if case/control)

For values other than {1,2,0,-9} it is assumed not to be case-control but numeric;
we're not going to support that!

** DONE Import/export /PED/ format [/]
   CLOSED: [2015-12-15 Tue 14:44]
   - State "DONE"       from "TODO"       [2015-12-15 Tue 14:44]
PED files are from plink. Description: http://www.gwaspi.org/?page_id=145.
ped files contain no headers and the first 6 columns are the same as those of
the FAM format.
Fields:
+ Family ID
+ Sample ID
+ Paternal ID
+ Maternal ID
+ Sex (1=male; 2=female; other=unknown)
+ Affection (0=unknown; 1=unaffected; 2=affected)
+ Genotypes (space or tab separated, 2 for each marker. 0=missing)


** DONE Include an argument =rm.singletons= allowing to keep/remove not connected individuals [6/6]
   CLOSED: [2015-12-18 Fri 13:27]
   - State "DONE"       from "TODO"       [2015-12-18 Fri 13:27]
+ [X] Implement a /generic/ method to do that: =removeSingletons=, had also
  =doPrunePed=, but that used graphs and was kinda slower.
+ *Note*: this has mainly an impact on the genealogical index, all other methods
  are not affected, i.e. return =NA= for such cases. Should I always make sure
  that these have =0= instead of =NA=.

Apply that as *first* task in any of the below methods.

+ [X] GI/GIF
+ [X] FIR
+ [X] FSIR
+ [X] KS
+ [X] KG



** TODO Implement the bayes based extension of the FSIR.

That will be pretty tricky as we can not compare results to anything.



* References
